[
  {
    "title": "마인크래프트 맵(월드) 저장위치 (자바 에디션/윈도우 에디션)",
    "url": "/posts/minecraft-save/",
    "categories": "마인크래프트",
    "tags": "마인크래프트 윈도우, 마인크래프트 자바, 마인크래프트 저장위치, minecraft save folder",
    "date": "2022-10-21 23:34:00 +0900",
    "snippet": "Minecraft 맵(월드) 저장위치Java Edition마인크래프트 자바 에디션의 맵이 저장되는 위치는 다음과 같다.  C:\\Users\\[유저이름]\\AppData\\Roaming\\.minecraft\\savesAppData 폴더는 숨겨진 폴더이므로 위 폴더로 직접 이동하려면 아래 그림처럼 탐색기의 보기에서 숨긴항목을 체크해 줘서 위의 위치로 찾아가면 된다.또는 window키 + R을 눌러 %appdata%를 치면 바로 C:\\Users\\[유저이름]\\AppData\\Roaming\\ 까지 가게 되는데 여기서 찾아 들어가면 더욱 쉽게 접근이 가능하다.  window키 + R를 누르면 위의 창이 뜨게 되고…  %appdata%를 치고 엔터를 치면 바로 위의 창이 뜨게 된다.최종적으로 ...\\saves 폴더에 들어가면 아래와 같이 내가 저장한 월드들이 보일 것이다. 이 폴더들을 플레이하고 싶은 다른 컴퓨터에 복사하면 플레이가 가능하다.Windows Edition마인크래프트 윈도우즈 에디션의 맵이 저장되는 위치는 다음과 같다.  C:\\Users\\[유저이름]\\AppData\\Local\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe/LocalState/games/com.mojang/minecraftWorlds/매우 길다…이번에는 AppData\\Roaming이 아닌 AppData\\Local이다.위의 두 방법 중 하나로 위의 폴더를 찾아 들어가보자.찾아가면 아래처럼 의미가 불문명한 폴더들이 나열되어 있을 것이다.해당 폴더에 들어가보면 levelname.txt라는 파일이 있는데 이 파일을 열어보자파일을 열면 아래처럼 어떤 문자가 적혀있을 것인데 이 문자가 바로 내가 저장한 월드의 제목이다.이제 해당 폴더를 원하는 곳에 복사하여 즐기면 된다.😄"
  },
  {
    "title": "Jekyll Blog에서 pyscript 줄바꿈 오류",
    "url": "/posts/jekyll-blog-pyscript-error/",
    "categories": "Python, PyScript",
    "tags": "jekyll, github, python, pyscript, 줄바꿈 오류, linebreak_error",
    "date": "2022-10-21 14:27:00 +0900",
    "snippet": "Jekyll Blog에서 pyscript 줄바꿈 오류Pyscript 줄바꿈 오류웹에서 Python code를 실행 시킬수 있다는 Pyscript를 알게 되어 test를 하던 중 Pyscript code가 2줄 이상이 되면 아래와 같은 오류를 띄우는 문제를 발견 하였다.JsException(PythonError: Traceback (most recent call last): File \"/lib/python3.10/site-packages/_pyodide/_base.py\", line 421, in eval_code CodeRunner( File \"/lib/python3.10/site-packages/_pyodide/_base.py\", line 237, in __init__ self.ast = next(self._gen) File \"/lib/python3.10/site-packages/_pyodide/_base.py\", line 141, in _parse_and_compile_gen mod = compile(source, filename, mode, flags | ast.PyCF_ONLY_AST) File \"\", line 1 from js import document content = document.getElementById(\"test3\").children[0] def main(): content = document.getElementById('test3').children[0] content.innerHTML = 'output3' main() ^^^^^^^ SyntaxError: invalid syntax )jekyll serve로 Local에서 Test할 때는 문제가 없었는데 왜 Deploy만 하면 문제가 생기는지 한참을 찾아 다녔다…문제가 무엇인지 이리저리 찾아보다 Deploy한 웹페이지에서 Ctrl + Shift + i를 눌러 웹페이지의 Source Code를 확인해 보니 웬걸 HTML Code가 아래처럼 한줄로 작성되어 있는 것이 아닌가?!Compress HTML아무리 검색을 해 봐도 관련 오류에 대한 내용은 아무도 다루고 있지를 않았다…좌절할 때쯤 Jekyll Blog의 여러 기능들을 살피다가 우연히 Compress HTML in Jekyll이라는 불필요한 whitespace, tag, comments등을 제거해 줘서 Compact한 HTML로 Refactoring 해주는 기능이 작동되고 있다는 것을 알게 되었다.  Compress HTML in Jekyll DocsCompress HTML이 적용되고 있는 Jekyll Blog에서는 설정에 따라 줄바꿈을 제거 하는 경우가 있는데 이 경우 &lt;py-script&gt; Tag안의 Code가 줄바꿈이 되지 않고 한줄로 작성되어 오류가 발생되는 것이다.  Compress HTML은 기본적으로 &lt;pre&gt;tag안의 내용은 줄바꿈을 제거하지 않기 때문에 &lt;py-script&gt;tag를 &lt;pre&gt;tag로 감싸줘도 문제는 해결된다.하지만, 매번 &lt;pre&gt;tag로 감싸주는 것도 일이니 근본적인 문제를 해결해 보도록 하자.Jekyll Blog에서 pyscript 줄바꿈 오류 해결!나와 같은 문제가 있는 사람이라면 _config.yml에 아래와 같이 compress_html의 속성이 보일 것이며 blanklines: false로 되어 있는 것을 확인 할 수 있을 것이다.compress_html:  clippings: all  comments: all  endings: all  profile: false  blanklines: false  # true로 하면 HTML Code가 줄바꿈된다.  ignore:    envs: [development]위 설정에서 blanklines: true한 후 Deploy하고 웹페이지에서 Source Code를 확인 해보면 아래처럼 HTML Code의 줄바꿈이 잘 되는 것을 확인 할 수 있다.이제 나의 Jekyll Blog에서도 py-script를 불편함 없이 마음껏 사용할 수 있게 되었다.😁"
  },
  {
    "title": "Python star args(*args)",
    "url": "/posts/Python-star_args/",
    "categories": "Python, 2.Functions",
    "tags": "python, args, star_args",
    "date": "2022-10-15 17:54:00 +0900",
    "snippet": "*argsPacking and Unpacking*arg에 대해서 알아보기 전에 Python의 Packing과 Unpacking에 대해서 알아보자.PackingPython에서는 a, b, c 이런식으로 변수를 콤마(,)로 나열해 쓰면 자동으로 Tuple로 Packing을 한다.a = 1b = 2c = 3t = a, b, cprint(t)(1, 2, 3)위 코드를 실행 하면 a, b, c는 (1, 2, 3) Tuple로 Packing이 되에 변수 t에 저장이 된 것을 확인 할 수 있다.실은 (1, 2, 3)과 1, 2, 3은 둘 다 모두 Tuple이다. Python은 콤마(, )가 있으면 Tuple로 인식을 한다.Unpacking이번에는 변수를 좌변(LHS: Left Hand Side)에 콤마로 나열해 주고 우변(RHS: Right Hand Side)에 List를 넣어줘 보자.l = ['a', 'b', 'c']a, b, c = lprint(a)print(b)print(c)abclist의 값이 a, b, c에 순서대로 들어간 것을 알 수 있다. 이게 Unpacking이다.그럼 list의 값이 좌변의 변수 개수보다 길 경우는 어떻게 되는지 확인 해 보자.l = ['a', 'b', 'c']a, b, c = lprint(a)print(b)print(c)---------------------------------------------------------------------------ValueError                                Traceback (most recent call last)Cell In [10], line 3      1 l = ['a', 'b', 'c', 'd']----&gt; 3 a, b, c = l      4 print(a)      5 print(b)ValueError: too many values to unpack (expected 3)Unpacking할 변수와 Assign할 변수의 개수가 맞지 않으면 ValueError를 띄운다.이걸 해 주는 것이 *변수이다.Iterable Unpacking이제 *args에 대해서 알아보자.a, b, *c = 10, 20, 30, 40, 50print(a, b, c)10 20 [30, 40, 50]RHS(right hand side) iterable인 (10, 20, 30, 40, 50)를 LHS(left hand side)로 unpacking을 할때 position에 맞게 assign이 되고 *c를 만나면 나머지를 list 형태로 assign을 한다.  이 때 *뒤에 오는 것은 python 변수형태로 어느것이든 될 수 있다.a, b, *c = 10, 20, 30print(a, b, c)10 20 [30]c에 assign될 value가 1개인 경우에도 list 형태로 assign 되는 것을 알 수 있다.*args가 unpacking 할 변수들 중간에 오는 경우도 살펴보자.a, *b, c = 10, 20, 30, 40, 50print(a, b, c)10 [20, 30, 40] 50*args가 중간에 오는 경우 처음과 끝을 제외한 나머지 value들이 list 형태로 assign 된다.Function Arguments(Parameters)def func1(a, b, *args):    print(a)    print(b)    print(args)func1(1, 2, 3, 4, 5)12(3, 4, 5)Function으로 여러 Parameter를 전달할 때 Iterable unpacking과 마찬가지로 남은 parameter들을 *arg에 assign한다.다만 Iterable unpacking과 다음과 같은 다른점이 존재한다.  List가 아닌 Tuple 형태로 assign된다.  Function에서는 *arg 다음에 positional argument가 올 수 없다.          이 이유는 keyword argument와 관계가 있는데 다음 포스팅에서 자세히 다뤄 보려 한다.      "
  },
  {
    "title": "GitHub(jekyll) Blog Deploy Error",
    "url": "/posts/deploy-fail/",
    "categories": "Git, Github-Blog",
    "tags": "blogging, jekyll, deploy, deploy fail",
    "date": "2022-09-23 13:30:00 +0900",
    "snippet": "GitHub pages Gem관련 Deploy 오류 발생GitHub pages로 Deploy하여 사용하는 Jekyll Theme Blog를 잘 사용하고 있는 중에 pyscript를 쓰려고 시도하던 중 pyscript의 code가 Deploy만 하면 온라인상에서 Code 줄바뀜이 안 되는 현상을 발견하였다. (local에선 잘 된다.)  pyscript Deploy 시 Code 줄바꿈 오류 해결 방법이걸 해결해 보려고 gemspec을 건드려보고 bundle update도 하는 등 이것저것 손을 막 댔다.그런데!! 갑자기 어느순간 Deploy Error가 뜨는것 아니겠는가!? 😢  Deploy Error가 생기면 아래 주황색 박스 친부분의 ✔가 ❌로 바뀌게 된다.이 부분을 클릭하면 Deploy Error Message를 볼 수 있는데 캡쳐는 하지 못하였고 아래와 같은 메세지를 띄우며 Deploy가 중지된다.Error: The process '/opt/hostedtoolcache/Ruby/2.7.6/x64/bin/bundle' failed with exit code 16아흑… gemspec등을 건드리면서 버젼도 바뀌고 등등 뭔가 바뀌긴 했는데 Deploy가 안된다니…어떤 분께서는 같은 오류를 page-deploy.yml의 ruby-version을 local에 깔려있는 ruby-version과 동일하게 설정해서 해결하신 분이 계신다. (아래 링크 참조)  https://velog.io/@hashnsalt/Github-Blog-%EB%A7%8C%EB%93%A4%EA%B8%B0-2그런데 내 경우는 이 방법으로 해결이 되질 않았다…Deploy 오류 해결구글링을 하다보니 gem version이나 spec 관련 오류는 gem을 싹 지우고 다시 세팅 하면 해결이 되는듯 했다.우선 gem cleanup을 하고 bundle update를 한 후 bundle install을 해주자.gem cleanup$ gem cleanupCleaning up installed gems...Attempting to uninstall tzinfo-data-1.2021.5Successfully uninstalled tzinfo-data-1.2021.5Attempting to uninstall tzinfo-1.2.9Successfully uninstalled tzinfo-1.2.9Attempting to uninstall rb-fsevent-0.11.0Successfully uninstalled rb-fsevent-0.11.0Attempting to uninstall jekyll-seo-tag-2.7.1Successfully uninstalled jekyll-seo-tag-2.7.1Attempting to uninstall jekyll-4.2.1Successfully uninstalled jekyll-4.2.1Attempting to uninstall rouge-3.27.0Successfully uninstalled rouge-3.27.0Attempting to uninstall kramdown-2.3.1Successfully uninstalled kramdown-2.3.1Attempting to uninstall jekyll-sass-converter-2.1.0Successfully uninstalled jekyll-sass-converter-2.1.0Attempting to uninstall i18n-1.8.11Successfully uninstalled i18n-1.8.11Attempting to uninstall html-proofer-3.19.3Successfully uninstalled html-proofer-3.19.3Attempting to uninstall parallel-1.21.0Successfully uninstalled parallel-1.21.0Attempting to uninstall nokogiri-1.13.1-x64-mingw32Successfully uninstalled nokogiri-1.13.1-x64-mingw32Attempting to uninstall concurrent-ruby-1.1.9Successfully uninstalled concurrent-ruby-1.1.9Attempting to uninstall addressable-2.8.0Successfully uninstalled addressable-2.8.0Attempting to uninstall public_suffix-4.0.6Successfully uninstalled public_suffix-4.0.6Clean up completebundle updateFetching gem metadata from https://rubygems.org/..........Resolving dependencies...Using bundler 2.3.5Using public_suffix 5.0.0Using colorator 1.1.0Using concurrent-ruby 1.1.10Using eventmachine 1.2.7 (x64-mingw32)Using http_parser.rb 0.8.0Using ffi 1.15.5 (x64-mingw32)Using forwardable-extended 2.6.0Using mercenary 0.4.0Using racc 1.6.0Using parallel 1.22.1Using rainbow 3.1.1Using yell 2.2.2Using rb-fsevent 0.11.2Using rexml 3.2.5Using liquid 4.0.3Using rouge 3.30.0Using safe_yaml 1.0.5Using unicode-display_width 1.8.0Using jekyll-paginate 1.1.0Using thread_safe 0.3.6Using wdm 0.1.1Using webrick 1.7.0Using em-websocket 0.5.3Using ethon 0.15.0Using i18n 1.12.0Using sassc 2.4.0 (x64-mingw32)Using rb-inotify 0.10.1Using terminal-table 2.0.0Using pathutil 0.16.2Using nokogiri 1.13.8 (x64-mingw32)Using tzinfo 1.2.10Using addressable 2.8.1Using typhoeus 1.4.0Using jekyll-sass-converter 2.2.0Using listen 3.7.1Using kramdown 2.4.0Using tzinfo-data 1.2022.3Using html-proofer 3.19.4Using kramdown-parser-gfm 1.1.0Using jekyll-watch 2.2.1Using jekyll 4.2.2Using jekyll-archives 2.2.1Using jekyll-redirect-from 0.16.0Using jekyll-seo-tag 2.8.0Using jekyll-sitemap 1.4.0Using jekyll-theme-chirpy 5.2.1 from source at `.`Bundle updated!1 installed gem you directly depend on is looking for funding.  Run `bundle fund` for detailsbundle installUsing public_suffix 5.0.0Using addressable 2.8.1Using bundler 2.3.5Using colorator 1.1.0Using concurrent-ruby 1.1.10Using eventmachine 1.2.7 (x64-mingw32)Using http_parser.rb 0.8.0Using em-websocket 0.5.3Using ffi 1.15.5 (x64-mingw32)Using ethon 0.15.0Using forwardable-extended 2.6.0Using mercenary 0.4.0Using racc 1.6.0Using nokogiri 1.13.8 (x64-mingw32)Using parallel 1.22.1Using rainbow 3.1.1Using typhoeus 1.4.0Using yell 2.2.2Using html-proofer 3.19.4Using i18n 1.12.0Using sassc 2.4.0 (x64-mingw32)Using jekyll-sass-converter 2.2.0Using rb-fsevent 0.11.2Using rb-inotify 0.10.1Using listen 3.7.1Using jekyll-watch 2.2.1Using rexml 3.2.5Using kramdown 2.4.0Using kramdown-parser-gfm 1.1.0Using liquid 4.0.3Using pathutil 0.16.2Using rouge 3.30.0Using safe_yaml 1.0.5Using unicode-display_width 1.8.0Using terminal-table 2.0.0Using jekyll 4.2.2Using jekyll-archives 2.2.1Using jekyll-paginate 1.1.0Using jekyll-redirect-from 0.16.0Using jekyll-seo-tag 2.8.0Using jekyll-sitemap 1.4.0Using jekyll-theme-chirpy 5.2.1 from source at `.`Using thread_safe 0.3.6Using tzinfo 1.2.10Using tzinfo-data 1.2022.3Using wdm 0.1.1Using webrick 1.7.0Bundle complete! 6 Gemfile dependencies, 47 gems now installed.Use `bundle info [gemname]` to see where a bundled gem is installed.1 installed gem you directly depend on is looking for funding.  Run `bundle fund` for details오오 gem을 uninstall 한 후 다시 설치를 하니 deploy가 잘 된다.gem을 건드려도 복구 할 방법을 알아 냈으니 이것저것 자신있게 손대봐도 될 것같다!!😁"
  },
  {
    "title": "PyScript 설치 및 DOM객체 접근",
    "url": "/posts/pyscript/",
    "categories": "Python, PyScript",
    "tags": "python, pyscript",
    "date": "2022-09-22 10:16:00 +0900",
    "snippet": "PyScriptAnaconda에서 HTML 웹페이지에서 python을 사용할 수 있는 PyScript를 출시 하였다.우선 pyscript를 이용해 \"Hello World\"를 찍어보겠다.&lt;py-script&gt;print(\"Hello World\")&lt;/py-script&gt;Loading...code_text = Element(\"pyresult2 &gt; .highlight .rouge-code &gt; pre\")code_text.write(\"Hello World\")F5를 눌러 refresh해 보면 위의 text output 창의 Hello World가 Loading...에서 Hello World로 바뀌는 것을 볼 수 있을 것이다.pyscript의 Runtime은 짧은데 처음 Loading될 때는 약간의 Loading Time이 존재하기 때문에 이런 현상이 눈에 띈다.이제 사용법을 알아보자.PyScript Install우선 pyscript를 Install 해보자.별다른건 없고 PyScript Page에 접속해 Install 버튼을 누르면 아래의 코드를 웹페이지에 삽입을 하라고 한다.&lt;link rel=\"stylesheet\" href=\"https://pyscript.net/latest/pyscript.css\" /&gt;&lt;script defer src=\"https://pyscript.net/latest/pyscript.js\"&gt;&lt;/script&gt;그런데 이 두줄의 코드를 일반적으로 하듯이 &lt;Head&gt; Tag에 넣어주면 아래와 같은 문제가 생긴다.  문제점      Stylesheet때문에 내 웹페이지의 Style이 망가진다.    pyscript.js의 Loading에 시간이 꽤 걸린다. 그래서 내 웹페이지에서 어떤 Action을 취할때 마다 무슨 로딩이 되는것 마냥 렉이 생긴다.  그래서 다음과 같은 방법으로 문제를 해결하고 사용 중이다.  해결책      stylesheet 삭제    Code 삽입 위치: &lt;head&gt; tag 내부가 아닌 pyscript를 사용하는 posting 내부에 위치.&lt;script defer src=\"https://pyscript.net/latest/pyscript.js\"&gt;&lt;/script&gt;  위의 방법으로 웹페이지 로딩이 느려지는 현상이 해결되었고, Style 예전 그대로를 유지하여 pyscript를 사용할 수 있게 되었다.PyScript 간단한 예제Print사실 위에서 작성한 pyscript 코드를 Markdown file에 넣어주게 되면 이 바로 아래찍히는 “Hello World” 처럼 &lt;div&gt;Tag로 아무런 Style이 없이 Print 된다.  (사실 print결과가 이 문장 바로 아래 표현이 될 수 있도록 id를 지정해 print 한 결과이다. 원래는 print를 하면 print 한 위치에 출력이 됐었는데 version이 바뀌어서 인지 id를 지정하지 않은 print 결과는 제일 마지막 pyscript 결과 뒤에 출력이 되는 듯하다. - 2022-10-08 기준)Loading...  Element('hello').write('Hello World')ID element 접근 및 수정pyscript 자체적으로 ID를 이용해 결과를 내보내는 방법이 두 가지가 있다.  가독성을 좋게하기 위해서 pyscript 출력이 될 tag에 자체 style을 적용하였다.1. Element('target-id').write('output1')를 이용하는 방법.  참고: pyscript.write('target-id', 'output')방법은 Deprecated 될 예정이라고함.&lt;p id=\"test1\" style=\"font-size: 1.5rem; color: orange;\"&gt;Loading...&lt;/p&gt;&lt;py-script&gt;  Element('test1').write('output1')&lt;/py-script&gt;Loading...  Element('test1').write('output1')2. Element로 자식요소 선택하는 방법.Id를 선택 할 수 있는 Element로 자식요소를 선택 할 수도 있다.나처럼 Web개발에 익숙치 않고 python으로 프로그래밍을 시작하신 분이라면 CSS 선택자가 익숙하지 않을 수도 있다.Real Python의 글을 읽다보니 CSS 선택자를 학습할 수 있는 재미있는 게임을 소개하고 있는데 관심이 있는 분은 여기를 클릭해서 연습해 보자.&lt;div id=\"test2\"&gt;  &lt;p style=\"font-size: 1.5rem; color: orange;\"&gt;Loading...&lt;/p&gt;&lt;/div&gt;&lt;py-script&gt;text_to_print = Element(\"test2 &gt; p\")text_to_print.write(\"Output2\")&lt;/py-script&gt;  Loading...text_to_print = Element(\"test2 &gt; p\")text_to_print.write(\"Output2\")3. py-script의 output 속성을 이용하는 방법.&lt;p id=\"test3\" style=\"font-size: 1.5rem; color: orange;\"&gt;Loading...&lt;/p&gt;&lt;py-script output=\"test3\"&gt;'Output3'&lt;/py-script&gt;Loading...'Output3'&lt;py-script&gt; Tag의 output 속성을 이용하면 원래 &lt;p&gt; Tag content인 \"Loading...\"을 그대로 두고 output인 Outpu3가 append되어 출력이 된다.출력 시 append기능을 원한다면 output 속성을 이용하면 된다.  output 속성을 이용할 경우 print 문을 쓰지 않고 Return 의 개념으로 작성을 해야 출력이 잘 된다.DOM 객체 접근 및 수정&lt;py-script&gt;에서 js를 import 하면 javascript의 global variable을 사용할 수 있다.js object 중 document object(DOM)를 이용하여 id가 test4인 tag의 자식 tag에 접근해 보도록 하자.&lt;div id=\"test4\"&gt;  &lt;p style=\"font-size: 1.5rem; color: orange;\"&gt;Loading...&lt;/p&gt;&lt;/div&gt;&lt;py-script&gt;from js import documentcontent = document.getElementById(\"test4\").children[0]content.innerHTML = \"output4\"&lt;/py-script&gt;  Loading...from js import documentdef main():    content = document.getElementById('test4').children[0]    content.innerHTML = 'output4'main()  문제점:kramdown parser가 deploy할때 &lt;py-script&gt; code의 줄바꿈을 하지 못하는 문제를 발견하였다.줄바꿈을 하지 못한 경우 아래와 같은 오류를 띄운다.JsException(PythonError: Traceback (most recent call last): File \"/lib/python3.10/site-packages/_pyodide/_base.py\", line 421, in eval_code CodeRunner( File \"/lib/python3.10/site-packages/_pyodide/_base.py\", line 237, in __init__ self.ast = next(self._gen) File \"/lib/python3.10/site-packages/_pyodide/_base.py\", line 141, in _parse_and_compile_gen mod = compile(source, filename, mode, flags | ast.PyCF_ONLY_AST) File \"\", line 1 from js import document content = document.getElementById(\"test3\").children[0] def main(): content = document.getElementById('test3').children[0] content.innerHTML = 'output3' main() ^^^^^^^ SyntaxError: invalid syntax )  해결책:이와 같은 오류가 발생하는 분 이라면 Jekyll Blog에서 pyscript 줄바꿈 오류 에 해결방법이 있으니 확인 바란다.여기까지가 pyscript의 설치방법과 주의사항 그리고 DOM객체 접근등에 대해서 간단한 예제로 살펴본 내용이다.PyScript를 사용함에 있어 javascript object를 py-script에서 사용이 가능하고, py-script object를 javascript에서도 사용이 가능하게 되어 있다.자세한 내용은 아래의 문서들을 참조 바란다.  “PyScript Docs”: https://docs.pyscript.net/latest/index.html“PyScript GitHub”: https://github.com/pyscript/pyscript“RealPython Docs”: https://realpython.com/pyscript-python-in-browser/#modules-missing-from-the-python-standard-library"
  },
  {
    "title": "Markdown 문법 및 Kramdown",
    "url": "/posts/markdown/",
    "categories": "Git, Github-Blog",
    "tags": "blogging, github, markdown, kramdown",
    "date": "2022-09-05 15:53:00 +0900",
    "snippet": "Markdown 문법Markdown Processors마크다운 프로세서는 우리가 *.md file에 적어주는 Markdown Syntax를 html syntax로 변환해 주는 놈이다.기본적인 기능은 비슷하나 Markdown Processor에 따라서 지원하는 기능이 조금씩 다른데 이 프로세서가 수십가지나 된다.  마크다운 프로세서의 종류: https://github.com/markdown/markdown.github.com/wiki/Implementations여기에선 일반적으로 통용되는 마크다운 문법과 kramdown processor에 대해서 정리하고 알아보려한다.Markdown Cheat-sheet            Element      Markdown Syntax      Remarks                  Heading      # H1  ## H2  ### H3  #### H4                     Bold      **텍스트 볼드체**                     Italic      *이탤릭체*                     Blockquote      &gt; 인용구                     Ordered List      1. First list  2. Second list  3. Third list                     Unordered List      - First list  - Second list  - Third list                     Inline Code      Inline Code Block                     Fenced Code Block      ```python &nbsp;&nbsp;&nbsp;&nbsp;print('hello world') ```       ```옆에 스타일링하려는 언어 명시              Horizontal Rule      ---                     Link      [title](https://www.link.com)                     Image      ![alt text](image path)                     Table      | Name | Description | | --- | --- | | Name1 | Description1 || Name2 | Description2 |      --- 대쉬는 3개 이상이면 된다.  :--- 좌측정렬  ---: 우측정렬 :---: 가운데정렬 테이블내 줄바꿈은 &lt;br&gt;태그사용              Foot Note      본문 내용...[^1]  …  [^1]: This is footnote                     Heading ID      ## Heading {#custon-id}                     Definition List      term  : definition      일부 Markdown Processor에서만 지원              Strike Throught      ~취소선~                     Task List      - [x] To Do 1  - [x] To Do 2  - [ ] To Do 3                     Emoji      Enjoy~ :joy:      일부 Markdown Processor에서만 지원 그냥 window key + .로 이모지를 넣는 것이 편함.              Highlight      ==Highlight text==      preview: text  일부 Markdown Processor에서만 지원              Subscript      H~2~O      일부 Markdown Processor에서만 지원              Superscript      X^2^      일부 Markdown Processor에서만 지원        Markdown문법에 대한 상세한 설명은 다음의 링크 참조: https://www.markdownguide.org/Markdown문법을 시연해 보려면 다음의 링크 참조: https://markdown-it.github.io/Kramdown 문법Chirpy Theme에서 사용하는 Kramdown본 블로그에서 사용하고 있는 테마인 Chirpy Theme는 Markdown Processor로 Kramdown을 사용한다.Kramdown은 기본 마크다운 문법에서 더 다양한 기능을 제공하는데 이 기능들이 매우 편리하다.한번 알아보도록 하자.HTML ID, Class, 속성 부여 가능Class SyntaxClass를 부여하는 방법은 {: }의 :뒤에 .custom_class를 적어주면 된다.아래의 예시를 보자.This is paragraph{:.orange}.orange {  color: orange;}결과This is paragraphID SyntaxID를 부여하는 방법은 {: }의 :뒤에 .custom_ID를 적어주면 된다.This is paragraph{:#id-red}#id-red {  color: red;}결과This is paragraph속성부여아래는 이 블로그의 avatar 이미지인데 일반 마크다운 문법으로 속성부여 없이 삽입한 예이다.이번에는 Kramdown을 이용해 Image 삽입 마크다운 문법에 속성을 부여해서 Max-width를 30%로 하는 예를 보겠다.![test-img](/assets/img/favicons/moon_circle.png){: style=\"max-width: 30%\"}결과Table of Content 삽입기능TOC Syntax아래와 같이 간단히 몇 글자만 삽입하면 Table of contents를 얻을 수 있다.- TOC{:toc}결과  Markdown 문법          Markdown Processors      Markdown Cheat-sheet        Kramdown 문법          Chirpy Theme에서 사용하는 Kramdown      HTML ID, Class, 속성 부여 가능                  Class Syntax          결과          ID Syntax          결과          속성부여          결과                    Table of Content 삽입기능                  TOC Syntax          결과                    여기까지 일반적인 Markdown 문법부터 Kramdown 문법까지 핵심을 정리해 보았다.더 상세한 내용이 궁금하신 분은 본문의 링크를 타고 들어가면 좋을 것이다.  Kramdown Syntex Tips and Tricks: https://about.gitlab.com/blog/2016/07/19/markdown-kramdown-tips-and-tricks/#Kramdown Whole Syntax: https://kramdown.gettalong.org/syntax.html"
  },
  {
    "title": "GitHub 블로그 무료 CDN 사용하기 - jsdelivr",
    "url": "/posts/github-blog-jsdelivr-cdn/",
    "categories": "Git, Github-Blog",
    "tags": "blogging, jekyll, github, free CDN, jsdelivr",
    "date": "2022-09-05 15:53:00 +0900",
    "snippet": "CDN아래의 지도는 해저케이블 지도이다.  제대로된 지도가 궁금하다면: https://www.submarinecablemap.com/바다를 건너 데이터를 전송할 때 저 해저케이블들을 통해서 데이터가 전송 되는 것인데, 아무리 데이터 전송속도가 빠르다 한들 물리적으로 먼 곳에서의 용량이 큰 데이터 다운로드는 상대적으로 매우 느릴 수 밖에 없다.그래서 만들어진 것이 CDN이라는 콘텐츠 전송 네트워크 이다.지리적으로 먼 곳에 있는 콘텐츠에 접속을 할 때 용량이 큰 이미지나 동영상의 경우 지리적으로 가까운 CDN 서버에 미리 저장 해 둬서 빠른 로딩을 경험 할 수 있게 해준다.  (e.g. 한국에서 미국의 웹사이트에 접속할 때 용량이 큰 콘텐츠는 미리 저장된 한국 CDN서버에서 다운로드 받아 웹사이트의 빠른 로딩이 가능하게 해 준다.)jsdelivr CDN 사용하기전 세계의 사용자가 내 블로그를 접속했을때 이미지 로딩으로 한참을 기다려야 할 수는 없다. 게다가 GitHub에 업로드 된 이미지는 CDN서버에 올라가지 않기 때문에 그냥 한국에서도 느리다.따라서, GitHub Jekyll Blog를 사용하려면 CDN 서비스의 이용이 필수라 할 수 있다.다행히도, GitHub Pages를 이용하여 Blog를 사용중이라면 jsdelivr로 무료 CDN을 사용 할 수 있다.사용법은 매우 간단하다.  따로 설치하거나 뭐 그런것 없이 GitHub 블로그에 업로드한 file의 file path 앞에 아래와 같은 정보들을 입력한 Link를 file path에 넣어주면 된다.https://cdn.jsdelivr.net/gh/github_user_name/repo_url@branch_name/file_path  이 블로그의 사용예로 아래와 같이 image를 넣으려는 곳에 cdn Link를 넣어주면 된다.![image](https://cdn.jsdelivr.net/gh/pioneergu/pioneergu.github.io@master/file_path){:.image-styling}  https://www.jsdelivr.com/github에 접속하여 GitHub에 업로드한 File의 Link를 입력하여 변환된 CDN Link를 얻을 수도 있다.Chirpy Theme에서 사용Chirpy Theme에서는 _config.yml파일에 img_cdn을 넣어주고 site에서 /로 시작하는 모든 이미지를 자동으로 CDN Link로 Parsing 해주는 기능이 있다.아래는 이 블로그 (Chirpy Theme)의 _config.yml의 CDN Link 자동으로 Parsing 해주는 것을 설정하는 부분을 발췌한 내용이다.# The CDN endpoint for images.# Notice that once it is assigned, the CDN url# will be added to all image (site avatar &amp; posts' images) paths starting with '/'## e.g. 'https://cdn.com'img_cdn: https://cdn.jsdelivr.net/gh/pioneergu/pioneergu.github.io@master참고사항  참고로 위에서 생성한 URL에 최초접속 시에 캐시가 되고, 12시간마다 캐시가 되므로 변경사항이 바로 바로 반영되진 않는다.Chirpy Theme의 CDN 자동 Parsing 기능의 문제 발견 및 해결Chirpy Theme의 CDN 자동 Parsing 기능 문제점나의 경우 Github pages의 1GB라는 저장소 한계 문제로 저장소 용량 관리를 위해서 Image업로드 할 때 Onedrive를 같이 사용하고 있다.(관련 내용은 여길 참조: https://pioneergu.github.io/posts/jekyll-github-blog-image-hosting/)그런데 Chirpy theme의 CDN Link 자동 parsing 기능을 켜니까 Onedrive에서 임배드하여 호스팅 한 이미지링크가 깨지는 것이 아니겠는가?이러면 안 되는데…크롬개발자도구를 열어 url 을 확인해 보니 자동 Parsing을 위해 _config.yml에 넣어준 img_cdn의 링크가 Onedrive에서 임배드 기능으로 생성된 link 중간에 아래의 노란 밑줄처럼 엉뚱한 곳에 들어가 있는 것이 아니겠는가?원래라면 https://로 시작하는 Onedrive link에는 변화가 없어야 하는데 말이다.이제 이걸 고쳐보자.🤞Chirpy theme의 jsdelivr cdn link 자동 파싱 기능 분석  시작 전 참고사항Jekyll theme의 경우 대부분이 Liquid template 언어로 작성이 되어 있다.나에게는 생소한 언어라서 Liquid의 Syntax를 찾아보니 꽤 직관적인 편이어서 이해하기 어렵지 않았다.나처럼 Liquid template 언어가 생소하신 분이라면 아래의 링크를 참조하면 도움이 되실겁니다.Liquid Syntax 참조: https://shopify.github.io/liquid/Chirpy Theme의 page.html을 보면 아래와 같이 Contents를 Refactoring하는 refactor-content.html을 include하는 부분이 보인다.{% capture _content %}  {% if layout.refactor or page.layout == 'page' %}    {% include refactor-content.html content=content %}  {% else %}    {{ content }}  {% endif %}{% endcapture %}아래의 코드는 page.html에서 불러오는 refactor-content.html인데 아래에 발췌한 코드는 image path에 ://가 없는 경우 _config.yml에서 지정해 준 img_cdn의 path를 image path 앞에 붙여 주는 역할을 하는 부분이다.{% assign _content = include.content %}{% assign IMG_TAG = '&lt;img ' %}{% if _content contains IMG_TAG %}  {% assign _img_content = nil %}  {% assign _img_snippets = _content | split: IMG_TAG %}  {% for _img_snippet in _img_snippets %}    {% if forloop.first %}      {% assign _img_content = _img_snippet %}      {% continue %}    {% endif %}    {% assign _width = nil %}    {% assign _height = nil %}    {% assign _src = nil %}    {% assign _left = _img_snippet | split: '&gt;' | first %}    {% assign _right = _img_snippet | remove: _left %}    {% assign _left = _left | remove: ' /' %}    {% assign _left = _left | replace: ' w=', ' width=' | replace: ' h=', ' height=' %}    {% assign _attrs = _left | split: ' ' %}    {% for _attr in _attrs %}      &lt;!-- 여기에서 img tag내의 내용을 `=`로 나누어서 attr의 key 와 value로 나누어줌 --&gt;      &lt;!-- 그런데 onedrive link에는 `=`가 패스에 많기 때문에 link가 쪼개짐. --&gt;      {% assign _pair = _attr | split: '=' %}      {% if _pair.size &lt; 2 %}        {% continue %}      {% endif %}              {% capture _key %}{{ _pair | first }}{% endcapture %}      &lt;!-- 여기가 오류가 생기는 부분 --&gt;      {% capture _value %}{{ _pair | last | replace: '\"', '' }}{% endcapture %}      {% case _key %}        {% when 'width' %}          {% assign _width = _value %}        {% when 'height' %}          {% assign _height = _value %}        {% when 'src' %}          {% assign _src = _value %}      {% endcase %}      {% if _width and _height and _src %}        {% break %}      {% endif %}    {% endfor %}    {% if _src %}      &lt;!-- src에 ://가 없는 경우 src에 img_cdn을 prefix 함. --&gt;      {% unless _src contains '://' %}        &lt;!-- Add CDN URL --&gt;        {% if site.img_cdn %}          {% if site.img_cdn contains '//' %}            {% assign _src_prefix = site.img_cdn %}          {% else %}            {% assign _src_prefix = site.img_cdn | relative_url %}          {% endif %}        {% else %}          {% assign _src_prefix = site.baseurl %}        {% endif %}        &lt;!-- Add image path --&gt;        {% if page.img_path %}          {% assign _path = page.img_path %}          {% assign last_char = _path | slice: -1 %}          {% unless last_char == '/' %}            {% assign _path = _path | append: '/' %}          {% endunless %}          {% assign _src_prefix = _src_prefix | append: _path %}        {% endif %}        {% assign _final_src = _src_prefix | append: _src %}        {% assign _left = _left | replace: _src, _final_src %}      {% endunless %}      &lt;!-- lazy-load images &lt;https://github.com/ApoorvSaxena/lozad.js#usage&gt; --&gt;      {% assign _left = _left | replace: 'src=', 'data-src=' %}    {% endif %}위 코드의 30번 Line에서 &lt;img&gt; tag내의 attribute를 =기준으로 split하여 [key, value] 형태의 list를 만들어 나누어 주게 된다.  예를들어 image tag가 &lt;img src=\"aaa.com/abc.png\"&gt; 라면,      _pair는 [src, aaa.com/abc.png]가 된다.  그리고나서 _pair list의 0번 index 값은 _key에,마지막 index는 _value에 넣게 되는데 image path가 일반적인 경우라면 문제가 되지 않는다.하지만, onedrive에서 임베드로 따온 link에는 link에 =가 매우 많기 때문에 이 방식에 문제가 생겨버린다.  원드라이브의 임베드 링크는 아래와 같은데,https://dsm01pap007files.storage.live.com/y … h3?width=660&amp;height=286&amp;cropmode=none이 경우 _pair는 아래와 같이 되므로 문제가 생긴다.      [src, https://dsm01pap007files.storage.live.com/y ... h3?width, 660&amp;height, 286&amp;cropmode, none]  Chirpy theme의 jsdelivr cdn link 자동 파싱 문제 해결이 부분을 해결하기 위해서 _pair의 size가 2가 넘어가는 경우 2번째 index부터 마지막까지 slice를 해서 _value에 assign 하는 방법으로 해결하였다.위 코드의 31번 부터 38번 Line을 아래와 같이 수정하였다 아래의 코드를 참조 바란다.{% if _pair.size &lt; 2 %}  {% continue %}&lt;!-- img_cdn 사용 시 원드라이브 src 오류 해결 코드 --&gt;{% elsif _pair.size == 2 %}  {% capture _key %}{{ _pair | first }}{% endcapture %}  {% capture _value %}{{ _pair | last | replace: '\"', '' }}{% endcapture %}{% elsif _pair.size &gt; 2 %}  {% capture _key %}{{ _pair | first }}{% endcapture %}  {% capture _value %}{{ _pair | slice: 1, -1 | replace: '\"', '' }}{% endcapture %}{% endif %}끝~!👍"
  },
  {
    "title": "실시간 차트의 MACD 지표계산 속도 비교 (pandas vs dictionary)",
    "url": "/posts/macd-pandas-vs-dict/",
    "categories": "System Trading, 0.Indicators",
    "tags": "macd, indicators, pandas, dictionary",
    "date": "2022-08-29 19:11:00 +0900",
    "snippet": "실시간 MACD 지표계산 코드작성 (pandas와 dictionary)Dictionary를 활용한 실시간 차트의 MACD 모의 계산은 이전글에서 다루었으니,pandas library를 사용하여 실시간 차트 모의계산 함수를 우선 만들도록 해보겠다.import randomimport datetimeimport timeitimport pandas as pdrandom.seed(0)  # 코드를 실행할 때마다 생성되는 Random 숫자가 동일하게 해주기class Indicators:    def __init__(self, tot_num):        \"\"\"        tot_num개의 OHLCV and MACD dict list 생성        \"\"\"        self.tot_num = tot_num        self.coro_adj_ewm = {}  # Coroutine 객체를 저장할 Dictionary    def get_ohlcv_macd_df(self, sets, use_concat=False, adjust=False, start_datetime=None):        if start_datetime is None:            start_datetime = datetime.datetime.now()        for cnt, num in enumerate(range(self.tot_num)):            dict_temp = {}            dict_temp['Date'] = (datetime.datetime(                                year=start_datetime.year,                                 month=start_datetime.month,                                 day=start_datetime.day,                                hour=(num // 24),                                minute=0+(num % 24), second=0, microsecond=0                                ).strftime('%Y-%m-%d %H:%M:%S'))            dict_temp['Open'] = random.randint(110, 115)            dict_temp['High'] = random.randint(110, 115)            dict_temp['Low'] = random.randint(110, 115)            dict_temp['Close'] = random.randint(110, 115)            dict_temp['Volume'] = random.randint(2100, 4000)            if cnt == 0:                df = pd.DataFrame(dict_temp, index=[\"Date\"])                # df = self.get_macd(df, sets)            elif cnt == 1:                df_tmp = pd.DataFrame(dict_temp, index=[\"Date\"])                if use_concat:                    df = pd.concat([df, df_tmp], ignore_index=True)                else:                    df = self.append_df(df, dict_temp)                df = self.get_macd(df, sets)            else:                df_tmp = pd.DataFrame(dict_temp, index=[\"Date\"])                # pandas Docs에 append는 v1.4.0 부터 deprecated 되었고,                 # deprecated 되기 전에도 concat이 더 효율적이라고 함.                if use_concat:                    df = pd.concat([df, df_tmp], ignore_index=True)                else:                    df = self.append_df(df, dict_temp)                df = self.append_macd(df, sets, adjust)        return df    def append_df(self, df, dict_):        df = df.append(pd.DataFrame(dict_, index=[dict_['Date']]),                                     ignore_index=True, sort=False)        return df    def append_macd(self, df, sets, adjust=False):        if adjust:            df.loc[df.index[-1]:, \"EMA_short\"] = df[\"Close\"].ewm(                                                    span=sets[\"short\"],                                                     adjust=True).mean()            df.loc[df.index[-1]:, \"EMA_long\"] = df[\"Close\"].ewm(                                                    span=sets[\"long\"],                                                     adjust=True).mean()        else:            df.loc[df.index[-1]:, \"EMA_short\"] = (df[\"Close\"].iloc[-1]                                                  * 2/(sets[\"short\"] + 1)                                                 + df[\"EMA_short\"].iloc[-2]                                                  *(1-2/(sets[\"short\"]+1)))            df.loc[df.index[-1]:, \"EMA_long\"] = (df[\"Close\"].iloc[-1]                                                 * 2/(sets[\"long\"] + 1)                                                 + df[\"EMA_long\"].iloc[-2]                                                 *(1-2/(sets[\"long\"]+1)))        df.loc[df.index[-1]:, \"MACD\"] = (df[\"EMA_short\"].iloc[-1]                                         - df[\"EMA_long\"].iloc[-1])        df.loc[df.index[-1]:, \"MACD_sig\"] = (df[\"MACD\"].iloc[-1]                                             * 2/(sets[\"signal\"]+1)                                             + df[\"MACD_sig\"].iloc[-2]                                             *(1-2/(sets[\"signal\"]+1)))        df.loc[df.index[-1]:, \"MACD_bool\"] = (df[\"MACD\"].iloc[-1]                                             &gt; df[\"MACD_sig\"].iloc[-1])        return dfindicator = Indicators(100)macd_set = {\"short\": 12, \"long\": 26, \"signal\": 9}df = indicator.get_ohlcv_macd_df(sets=macd_set, use_concat=True, adjust=True)print(df)모의 실시간 차트의 MACD 지표계산을 pandas DataFrame을 이용하여 계산한 결과도 역시 동일하다.                     Close    MACD       MACD_sig     MACD_boolDate                2022-08-29 00:00:00    112    0.000000    0.000000    False2022-08-29 00:01:00    113    0.022436    0.012464    True2022-08-29 00:02:00    111    -0.033432    0.003285    False2022-08-29 00:03:00    112    -0.021918    -0.001756    False2022-08-29 00:04:00    111    -0.054992    -0.012403    False...    ...    ...    ...    ...2022-08-29 03:23:00    113    -0.024678    0.008761    False2022-08-29 04:00:00    114    0.141292    0.035267    True2022-08-29 04:01:00    115    0.349447    0.098103    True2022-08-29 04:02:00    112    0.269341    0.132351    True2022-08-29 04:03:00    113    0.283249    0.162530    True100 rows × 4 columns결과가 동일한 것은 확인 했으니 이제 그럼 계산에 걸리는 시간을 python의 standard library인 timeit으로 계산해 비교해 보도록 하겠다.pandas와 Dictionary의 계산 시간 비교pandas를 이용한 계산 시간timeit을 import하여 계산을 100번 반복해 걸리는 시간을 비교해 보도록 하겠다. 한 번 계산당 100개의 봉차트를 계산하므로 총 10,000개의 계산을 하는데 걸리는 시간이다.우선 pandas DataFrame을 한 개 한 개 append하는 계산 결과를 보려 한다. 계산 조건은 다음과 같다.  pandas 1.4.0 버전부터 Deprecated 된 append 말고 기존 버젼에서도 더 efficient하다고 한 concat으로 계산ewm의 계산은 동일성을 위해 adjust=True로 계산import timeittimeit.timeit(\"indicator.get_ohlcv_macd_df(sets=macd_set, use_concat=True, adjust=True)\", globals=globals(), number=100)31.385306799998943약 31초가 걸린다. 이 결과가 10,000개 계산에 대한 결과이니 1개의 지표계산에 걸리는 시간은 약 0.0031초(3ms) 정도가 된다. 그래도 꽤 빠르다고 느낄 수 있다. 그런데 실제로 System Trading을 하기 위해서는 이런 지표를 시간봉별, 틱봉별, 지표별 조합을 하여 여러 지표를 계산해 진입 및 청산에 대한 판단을 하게 될텐데, 이런 계산을 10개만 한다 해도 30ms로 빠르게 움직이는 상황에서는 수익의 감소 또는 손실의 증가의 결과로 이어질 수 있다.Dictionary를 이용한 계산 시간이번에는 Dictionary로 지표계산을 10,000번 할때 걸리는 시간을 계산해 보도록 해보자.import timeittimeit.timeit(\"indicator.get_ohlcv_macd_dict(sets=macd_set, adjust=True)\", globals=globals(), number=100)0.19308430000091903약 0.2초가 걸린다 앞의 계산보다 150배 정도 빠른 결과이다. 1개의 지표계산당 0.02ms가 걸리는 셈이다.보통 인터넷 ping이 2ms면 빠르다고 표현하는데 지표를 동시에 100개를 계산 해도 빠른 ping 수준이다. 이정도면 계산 속도 때문에 거래를 망치는 일은 없을 것이라 판단된다.  다시 한 번 말하지만 위의 결과는 실시간으로 생성되는 OHLCV Data를 DataFrame객체로 만드는 과정(Bottle Neck)이 있을 수 밖에 없기 때문에 pandas의 계산 시간이 느린 것으로 보이는 것이지, 이미 한 번에 생성된 방대한 Data의 계산에는 pandas가 훨씬 빠르다는 점을 참조해 주기 바란다.끝~😁"
  },
  {
    "title": "깃허브(GitHub, jekyll) 블로그 이미지 호스팅 하기 (원드라이브, 구글드라이브)",
    "url": "/posts/jekyll-github-blog-image-hosting/",
    "categories": "Git, Github-Blog",
    "tags": "blogging, jekyll, github, onedrive, googledrive, image, hosting",
    "date": "2022-08-25 21:05:00 +0900",
    "snippet": "GitHub 저장소 제한 사항예전에 지킬(jekyll)을 이용해 깃허브 페이지로 블로그를 만들었는데,깃허브 블로그는 1GB를 넘을 수 없고, 트래픽은 한달에 100GB로 제한되어 있다는 사실을 알게 되었다.이런저런 이미지도 올리면서 블로깅을 하고 싶었는데… 1MB짜리 이미지 1,000 장이면 끝나는 것 아닌가?!  출처: GitHub Docs지금 당장엔 아무런 문제가 없을지 몰라도 이미지가 많아지고 블로그가 커지면 골치가 아플것 같단 생각을 했다.(물론 블로깅을 열심히 한다는 전제하에 이야기이긴하다… 꾸준히 할 수 있는지의 여부를 떠나 이제 시작하는데 당연히 열심히 한다는 가정하에 결정을 하는 것이 사람 심리가 아닌가!)이미지 업로드에 대한 막연한 불안감에 티스토리 블로그를 시작하게 되었다.그런데 웬걸… 티스토리는 마크다운을 완전하게 지원하지 않고 있는 것이다…  제대로 지원하지 않는 마크다운은 다른 내용을 수정하러 들어갔을때 바뀌어 있어서 다시 손을 봐줘야 한다.매우 번거롭다…마크다운 문법을 선호하는 나로서는 이 또한 골아픈 문제가 아닐 수 없다.그러던 와중에 클라우드에 저장된 이미지의 링크를 생성해서 깃허브 블로그에 임배드해서깃허브 저장소를 사용하지 않고 이미지를 호스팅 할 수 있다는 것을 알게 되었다.여담이지만, 깃허브 블로그의 이미지에 대한 걱정이 해결되니 깃허브 블로그로 넘어가고 싶어졌다. 그런데 이미 만든 티스토리 블로그도 아깝다는 생각이 동시에 드는 것이 아닌가…그래서 둘다 운영하는것이 좋겠다 생각했지만…음… 일단은 코드관련이나 마크다운 작성이 편한 내용은 GitHub에 그 외 일반 포스팅은 Tistory에 하는 것이 좋지 않을까 생각 중이다…아참 그리고 jsdelivr라는 무료 CDN이 있는데 jsdelivr를 이용해 GitHub Pages에 올린 Image Link로 바로 CDN을 사용할 수 있다.  자세한 내용은 여기 참조: GitHub 블로그 무료 CDN 사용하기 - jsdelivr여기에서 CDN 서비를 사용하려면 우선 깃허브 repository에 이미지를 업로드 하고 이미지 Link만 바꿔 주면 빠른 CDN 서비스를 무료로 사용할 수 있다.다만, GitHub Blog의 용량 제한에 걸리지 않으려면 Page의 Background Image나 Title Image등은 CDN을 사용하고, 블로그 포스팅에 들어가는 이미지는 원드라이브와 같은 Cloud Service를 사용하는 것이 좋을 것 같다.이제 원드라이브나 구글드라이브 같은 클라우드 서비스를 활용한 이미지 호스팅에 대해서 알아보자~원드라이브 이미지 호스팅먼저 마이크로소프트의 원드라이브를 사용해 이미지 호스팅을 하는 방법을 알아보겠다.사실 원드라이브의 경우 블로그나 웹페이지에 이미지등 호스팅이 가능하게 임베드 기능을 제공하고 있다.우선 내 원드라이브를 웹(온라인 보기)으로 접속한다.온라인 보기를 하려면 우측하단 작업표시줄의 원드라이브 아이콘을 클릭하여 나타나는 창의 온라인 보기를 클릭한다.  원드라이브 데스크톱버젼을 사용하지 않는 경우 아래의 링크로 들어가서 웹으로 접속하면 된다.https://onedrive.live.com/다음으로 Blog에 호스팅할 이미지들을 모을 폴더를 하나 생성을 하고 거기에 이미지를 업로드 한다.그 다음 아래처럼 원하는 이미지를 체크하고 우측 상단의 임베드 버튼을 눌러준다.그러면 우측에 “블로그나 웹 페이지에 ~ 임베드”라는 타이틀과 함께 HTML 코드 생성 버튼이 생긴다~이 버튼을 눌러주자.그러면 아래와 같이 URL이 생성이 되는데 이 URL을 image tag에 넣어주거나 마크다운에서 이미지 링크를 걸어주면 된다.  이미지 크기 부분을 클릭하면 불필요하게 큰 이미지를 줄일 수도 있다~아래의 이미지는 원드라이브에서 생성한 URL로 삽입한 이미지이다~😁생각보다 매우 간단하다~다음으로 구글드라이브에서 이미지 호스팅을 하는 방법을 보겠다.구글드라이브 이미지 호스팅구글드라이브 데스크톱버젼을 설치했다면 탐색기로 호스팅할 이미지가 있는 곳으로 간 후 마우스 우클릭을 해서Google Drive로 공유를 누르거나~만약 웹으로 접속을 했다면 마찬가지로 원하는 이미지 우클릭을 누르고 공유 버튼을 누른다~그러면 아래와 같은 창이 뜨는데 여기서 일반 액세스의 제한됨을 링크가 있는 모든 사용자로 바꿔주고, 링크복사를 눌러서 링크를 복사한다.  복사된 링크를 붙여넣기하면 아래와 같은 URL이 나오는데 아래의 주황색 글자가 공유된 이미지의 ID 이다.      https ://drive.google.com/file/d/101lUDe0hzbJZMUmu8evcR\\_I5BpqVIybt/view?usp=sharing    해당 ID를 https://drive.google.com/uc?export=view&amp;id=뒤에 붙여 넣어 아래와 같은 URL을 만든다.      https ://drive.google.com/uc?export=view&amp;id=101lUDe0hzbJZMUmu8evcR\\_I5BpqVIybt  이 생성된 URL을 이미지 링크 부분에 넣어주면 끝!아래는 구글 드라이브에서 생성한 링크로 호스팅한 이미지 이다.두 가지 방법을 다 해보니 개인적으로 외부로의 공유제한 풀기와 링크의 수동 수정이 없는 원드라이브의 이미지 호스팅 방법이 훨씬 편한것 같다.각자의 사정에 맞게 잘 골라서 쓰면 될 듯하다~😎  Image 로딩에 걸리는 시간을 정확히 Test 해보진 않았지만,이 페이지에 접속했을때 원드라이브의 이미지 로딩이 훨씬 빠른 느낌이다…"
  },
  {
    "title": "MACD 지표의 python 코드 작성 (Pandas library and Dictionary)",
    "url": "/posts/macd-code/",
    "categories": "System Trading, 0.Indicators",
    "tags": "macd, indicators, pandas, dictionary",
    "date": "2022-08-24 21:06:00 +0900",
    "snippet": "MACD 지표의 python 코드 작성 (by Pandas library)Pandas 설치pandas library를 사용하려면 당연하게도 pandas library를 설치 해야한다.아래와 같이 나의 환경관리 툴에 맞게 설치를 해준다.# PyPi (python package index 환경)&gt; pip install pandas# Conda (anaconda or miniconda 환경)&gt; conda install pandasData 준비OHLCVMACD를 계산할 OHLCV (Open, High, Low, Close, Volume)의 Data가 필요하다.요즘은 각종 증권사이트나 암호화폐 사이트에서 API를 이용하거나 크롤링을 하는 방식으로내가 원하는 종목의 데이터를 가져올 수 있다.하지만, 여기선 가상의 데이터를 만들어서 MACD 지표를 계산하려고 한다.import datetimeimport randomrandom.seed(0)  # 코드를 실행할 때마다 생성되는 Random 숫자가 동일하게 해주기def get_random_price_dict(tot_num, start_datetime=None):    \"\"\"tot_num개의 OHLCV data list 생성\"\"\"    if start_datetime is None:        start_datetime = datetime.datetime.now()    ohlcv_dict_list = []  # OHLCV Data의 Dictionary를 List에 append.    for num in range(tot_num):        dict_temp = {}        dict_temp['Date'] = (datetime.datetime(                            year=start_datetime.year,                             month=start_datetime.month,                             day=start_datetime.day,                            hour=start_datetime.hour+(num // 24),                            minute=0+(num % 24), second=0, microsecond=0                            ).strftime('%Y-%m-%d %H:%M:%S'))        dict_temp['Open'] = random.randint(110, 115)        dict_temp['High'] = random.randint(110, 115)        dict_temp['Low'] = random.randint(110, 115)        dict_temp['Close'] = random.randint(110, 115)        dict_temp['Volume'] = random.randint(2100, 4000)        ohlcv_dict_list.append(dict_temp)    return ohlcv_dict_listohlcv_dict_list = get_random_price_dict(100)print(ohlcv_dict_list)[{'Date': '2022-08-24 00:00:00', 'Open': 113, 'High': 113, 'Low': 110, 'Close': 112, 'Volume': 3147}, {'Date': '2022-08-24 00:01:00', 'Open': 113, 'High': 113, 'Low':112, 'Close': 113, 'Volume': 2833}, {'Date': '2022-08-24 00:02:00', 'Open': 114, 'High': 111, 'Low': 114, 'Close': 111, 'Volume': 2677}, {'Date': '2022-08-24 00:03:00','Open': 111, 'High': 110, 'Low': 114, 'Close': 112, 'Volume': 3963}, {'Date': '2022-08-24 00:04:00', 'Open': 114, 'High': 115, 'Low': 114, 'Close': 111, 'Volume':2735}, {'Date': '2022-08-24 00:05:00', 'Open': 110, 'High': 115, 'Low': 110, 'Close':115, 'Volume': 2776}, {'Date': '2022-08-24 00:06:00', 'Open': 113, 'High': 114, 'Low':110, 'Close': 112, 'Volume': 2989}, {'Date': '2022-08-24 00:07:00', 'Open': 112, 'High': 114,Random으로 만들어진 OHLCV Ditionary List가 생성 되었다.아니 근데 이게 뭐가 뭔지 지저분해서 보기가 너무 힘들다.pprint 사용해서 보기 좋게 출력해보자.from pprint import pprint......pprint(ohlcv_dict_list)[{'Close': 112,  'Date': '2022-08-24 00:00:00',  'High': 113,  'Low': 110,  'Open': 113,  'Volume': 3147}, {'Close': 113,  'Date': '2022-08-24 00:01:00',  'High': 113,  'Low': 112,  'Open': 113,  'Volume': 2833},  ...  ...  ]이제 보기 좋게 출력이 되었고 OHLCV Data가 구조에 맞게 제대로 생성되었는지 확인이 가능하고,random.seed(임의의 수)를 사용하여 여러번 반복 실행을 해도 동일한 Data가 생성되는 것을 확인 할 수 있다.OHLCV PandasOHLCV를 Dictionary 형태로 만들었으니 이제 pandas의 Dataframe 객체로 변환을 해 보자.import pandas as pddf = pd.DataFrame.from_dict(ohlcv_dict_list)print(df)                Date       Open   High    Low   Close  Volume0    2022-08-28 12:00:00    113    113    110    112    31471    2022-08-28 12:01:00    113    113    112    113    28332    2022-08-28 12:02:00    114    111    114    111    26773    2022-08-28 12:03:00    111    110    114    112    39634    2022-08-28 12:04:00    114    115    114    111    2735...    ...    ...    ...    ...    ...    ...95    2022-08-28 15:23:00    115    111    110    113    211696    2022-08-28 16:00:00    110    113    114    114    269397    2022-08-28 16:01:00    113    113    114    115    349198    2022-08-28 16:02:00    111    113    110    112    255099    2022-08-28 16:03:00    112    114    111    113    2493100 rows × 6 columnsPandas의 Dataframe 객체로 Data의 변환이 잘 된 것을 볼 수 있다.그런데 Index가 0~99로 숫자이다.내가 원하는 것은 Index가 Date 인 객체이므로 set_index함수를 통해 Index를 바꿔보도록 하자.df.set_index('Date', inplace=True)print(df)                      Open    High   Low   Close  VolumeDate                    2022-08-28 12:00:00    113    113    110    112    31472022-08-28 12:01:00    113    113    112    113    28332022-08-28 12:02:00    114    111    114    111    26772022-08-28 12:03:00    111    110    114    112    39632022-08-28 12:04:00    114    115    114    111    2735...    ...    ...    ...    ...    ...2022-08-28 15:23:00    115    111    110    113    21162022-08-28 16:00:00    110    113    114    114    26932022-08-28 16:01:00    113    113    114    115    34912022-08-28 16:02:00    111    113    110    112    25502022-08-28 16:03:00    112    114    111    113    2493100 rows × 5 columnsIndex가 Date로 잘 변환 된 것을 확인 할 수 있다.  ※여기서 중요한점은 Pandas Dataframe 객체를 한번에 생성해야 한다는 것이다.Pandas는 C언어로 작성되어 사용하여 Data Science에서 필요한 대량의 계산을 빠르게 처리해 주는데객체 생성을 할 때에는 어쩔수 없이 상대적으로 큰 시간이 소요된다.따라서 만일, 위에서 Dictionary List를 만들때 한개의 Data마다 Dataframe 객체를 생성하게 되면,큰 Data를 다룰 때 매우 느린 것을 경험 할 수 있을 것이다.Pandas의 장점을 살릴 수가 없게 되는 것이다.MACD 함수 by pandasOHLCV Data의 준비가 되었으니 이번에는 MACD 함수를 만들어 보도록 하자.def get_macd(df, sets):    df[\"EMA_short\"] = df[\"Close\"].ewm(span=sets[\"short\"], adjust=True).mean()    df[\"EMA_long\"] = df[\"Close\"].ewm(span=sets[\"long\"], adjust=True).mean()    df[\"MACD\"] = df[\"EMA_short\"] - df[\"EMA_long\"]    df[\"MACD_sig\"] = df[\"MACD\"].ewm(span=sets[\"signal\"], adjust=True).mean()    df[\"MACD_bool\"] = df[\"MACD\"] &gt; df[\"MACD_sig\"]    df.drop(columns = [\"EMA_short\", \"EMA_long\"], inplace=True)    return dfget_macd 함수를 만들었으니 아까 만들어진 Data로 MACD계산을 해보자import datetimeimport randomimport pandas as pdrandom.seed(0)  # 코드를 실행할 때마다 생성되는 Random 숫자가 동일하게 해주기def get_random_price_dict(tot_num, start_datetime=None):    \"\"\"tot_num개의 OHLCV data list 생성\"\"\"    if start_datetime is None:        start_datetime = datetime.datetime.now()    ohlcv_dict_list = []  # OHLCV Data의 Dictionary를 List에 append.    for num in range(tot_num):        dict_temp = {}        dict_temp['Date'] = (datetime.datetime(                            year=start_datetime.year,                             month=start_datetime.month,                             day=start_datetime.day + (num // 24),                            minute=0+(num % 24), second=0, microsecond=0                            ).strftime('%Y-%m-%d %H:%M:%S'))        dict_temp['Open'] = random.randint(110, 115)        dict_temp['High'] = random.randint(110, 115)        dict_temp['Low'] = random.randint(110, 115)        dict_temp['Close'] = random.randint(110, 115)        dict_temp['Volume'] = random.randint(2100, 4000)        ohlcv_dict_list.append(dict_temp)    return ohlcv_dict_listdef get_macd(df, sets):    df[\"EMA_short\"] = df[\"Close\"].ewm(span=sets[\"short\"], adjust=True).mean()    df[\"EMA_long\"] = df[\"Close\"].ewm(span=sets[\"long\"], adjust=True).mean()    df[\"MACD\"] = df[\"EMA_short\"] - df[\"EMA_long\"]    df[\"MACD_sig\"] = df[\"MACD\"].ewm(span=sets[\"signal\"], adjust=True).mean()    df[\"MACD_bool\"] = df[\"MACD\"] &gt; df[\"MACD_sig\"]    df.drop(columns = [\"Open\", \"High\", \"Low\", \"Volume\",                        \"EMA_short\", \"EMA_long\"], inplace=True)                       # 결과의 가독성을 위해 불필요한 부분 삭제    return dfohlcv_dict_list = get_random_price_dict(100)df = pd.DataFrame.from_dict(ohlcv_dict_list)df.set_index('Date', inplace=True)macd_set = {\"short\": 12, \"long\": 26, \"signal\": 9}df = get_macd(df_test, macd_set)print(df)                      Close    MACD    MACD_sig    MACD_boolDate                2022-08-28 12:00:00    112    0.000000    0.000000    False2022-08-28 12:01:00    113    0.022436    0.012464    True2022-08-28 12:02:00    111    -0.033432    -0.006346    False2022-08-28 12:03:00    112    -0.021918    -0.011621    False2022-08-28 12:04:00    111    -0.054992    -0.024523    False...    ...    ...    ...    ...2022-08-28 15:23:00    113    -0.024678    0.008761    False2022-08-28 16:00:00    114    0.141292    0.035267    True2022-08-28 16:01:00    115    0.349447    0.098103    True2022-08-28 16:02:00    112    0.269341    0.132351    True2022-08-28 16:03:00    113    0.283249    0.162530    TrueMACD 계산 결과가 잘 출력되는 것을 볼 수 있다.(여기서 True는 매수, False는 매도이다.)여기까지는 Pandas Library를 활용하여 대량의 OHLCV Data의 MACD를 일괄계산하는 방법에 대해 알아보았다. 다음으로는 MACD계산을 python standard 객체인 Dictionary로 계산하는 방법에 대해서 알아보겠다.MACD 지표의 python 코드 작성 (by Dictionary)실시간으로 생성된 OHLCV 차트에 Dictionary로 지표계산을 하는 이유앞에서 pandas DataFrame으로 계산한 MACD지표는 과거의 수 많은 Data table에서 한꺼번에 MACD지표를 계산하는 방법이다.과거의 방대한 Data로 내 거래 기준을 테스트하는 Back Testing과 같은 대량의 계산에는 C언어 기반으로 작성된 pandas DataFrame을 사용하는 것이 가장 빠르고 효율적이다.다만, 실제 거래를 위해서 실시간으로 Data를 받아서 봉을 만들고 지표계산을 한 개씩 하는 경우엔 이야기가 달라지게 된다. pandas DataFrame의 경우 Data를 DataFrame 객체로 변환을 해줘야 하는데 이 과정이 상대적으로 매우 느린 과정이다.실시간으로 생성되는 OHLCV Data로 지표 계산은 Dictionary로 계산하는 것이 pandas 계산보다(객체생성 과정 때문에) 월등히 (약 100배 가량) 빠른데자세한 내용 및 속도비교는 아래의 링크를 확인하면 확실히 알 수 있을 것이다.  실시간으로 생성되는 차트의 MACD 지표계산 속도 비교: https://pioneergu.github.io/posts/macd-pandas-vs-dict/실시간 MACD 지표 모의 계산앞서 계산과 마찬가지로 random library를 사용하여 실시간 MACD 지표 계산을 모의로 계산해보겠다.앞에서 작성한 Random Price Dict를 생성하는 Loop 계산에 OHLCV Data dictionary가 생성되는 대로 MACD 지표를 계산하는 방식으로 진행 할 것이다.우선 Dictionary에서 MACD 지표를 한줄 한줄 계산하는 함수를 짜 볼 것인데, Exponential Weighted Moving Avarage 계산 특성상 과거 값이 계속 보정이 되기때문에 (아래의 수식 참조) Coroutine을 써야 한다.  &lt;출처 Pandas Docs: https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.ewm.html)근데 이 Coroutine을 함수 내부에서 불러오려 하는데 함수를 빠져나갈때 Coroutine 객체가 garbage collection 되지 않도록 하기 위해 편의를 위해서 코드를 Class로 작성 하도록 하겠다. (Closure를 사용해도 된다.)import randomimport datetimerandom.seed(0)  # 코드를 실행할 때마다 생성되는 Random 숫자가 동일하게 해주기class Indicators:    def __init__(self, tot_num):        \"\"\"        tot_num개의 OHLCV and MACD dict list 생성        \"\"\"        self.tot_num = tot_num        self.coro_adj_ewm = {}  # Coroutine 객체를 저장할 Dictionary    def get_ohlcv_macd_dict(self, sets, adjust=False, start_datetime=None):        if start_datetime is None:            start_datetime = datetime.datetime.now()        ohlcv_dict_list = []  # OHLCV Data의 Dictionary를 List에 append.        for num in range(self.tot_num):            dict_temp = {}            dict_temp['Date'] = (datetime.datetime(                                year=start_datetime.year,                                 month=start_datetime.month,                                 day=start_datetime.day,                                hour=(num // 24),                                minute=(num % 24), second=0, microsecond=0                                ).strftime('%Y-%m-%d %H:%M:%S'))            dict_temp['Open'] = random.randint(110, 115)            dict_temp['High'] = random.randint(110, 115)            dict_temp['Low'] = random.randint(110, 115)            dict_temp['Close'] = random.randint(110, 115)            dict_temp['Volume'] = random.randint(2100, 4000)            ohlcv_dict_list.append(dict_temp)            ohlcv_dict_list = self.append_macd_dict(ohlcv_dict_list,                                                    sets, adjust=adjust)        df = pd.DataFrame.from_dict(ohlcv_dict_list)        # 보기 편하게 마지막에 df로 변환        df.set_index('Date', inplace=True)        df.drop(columns = [\"Open\", \"High\", \"Low\", \"Volume\",                            \"EMA_short\", \"EMA_long\"], inplace=True)        return df    def append_macd_dict(self, dict_list, sets, adjust):        dict_list[-1][\"EMA_short\"] = self.get_ewm(dict_list,                                                   close_key=\"Close\",                                                   span_key=\"short\",                                                   span=sets[\"short\"],                                                   adjust=adjust)        dict_list[-1][\"EMA_long\"] = self.get_ewm(dict_list,                                                  close_key=\"Close\",                                                  span_key=\"long\",                                                  span=sets[\"long\"],                                                  adjust=adjust)        dict_list[-1][\"MACD\"] = (dict_list[-1][\"EMA_short\"]                                 - dict_list[-1][\"EMA_long\"])        dict_list[-1][\"MACD_sig\"] = self.get_ewm(dict_list,                                                  close_key=\"MACD\",                                                  span_key=\"signal\",                                                  span=sets[\"signal\"],                                                  adjust=adjust)        dict_list[-1][\"MACD_bool\"] = (dict_list[-1][\"MACD\"]                                     &gt; dict_list[-1][\"MACD_sig\"])        return dict_list    def get_ewm(self,                 dict_list: list,                 close_key: str=\"Close\",                 com: float=None,                 span_key: str=None,                span: float=None,                 adjust: bool=False) -&gt; float:        if not any([com, span]):            raise KeyError(\"One of com and span must be provided.\")        if com:            if com &lt; 0:                raise ValueError(\"com &gt;= 0\")            else:                alpha = 1/(1+com)        elif span:            if span &lt; 1:                raise ValueError(\"span &gt;= 1\")            else:                alpha = 2/(span+1)        if adjust:            if len(dict_list) == 1:                self.coro_adj_ewm[span_key] = self.adjust_ewm(alpha)                next(self.coro_adj_ewm[span_key])                return (self.coro_adj_ewm[span_key]                        .send(dict_list[-1][close_key]))            else:                return (self.coro_adj_ewm[span_key]                        .send(dict_list[-1][close_key]))        else:            if len(dict_list) == 1:                return dict_list[-1][close_key]            else:                return ((1-alpha) * dict_list[-2]                        + alpha * dict_list[-1][close_key])    def adjust_ewm(self, alpha):        numerator = 0        denominator = 1        count = 0        while True:            close = yield numerator/denominator            if count == 0:                denominator = 0            numerator = numerator * (1-alpha) + close            denominator += (1-alpha) ** count            count += 1indicator = Indicators(100)macd_set = {\"short\": 12, \"long\": 26, \"signal\": 9}df = indicator.get_ohlcv_macd_dict(sets=macd_set, adjust=True)print(df)결과의 가독성을 좋게 하기 위해서 Dictionary로 계산을 다 한 후에 마지막에 일괄로 df로 변환하는 과정만 추가해 주었다.아래의 결과를 보면 pandas library로 계산한 결과와 동일함을 알 수 있다.                      Close   MACD        MACD_sig    MACD_boolDate                2022-08-29 00:00:00    112    0.000000    0.000000    False2022-08-29 00:01:00    113    0.022436    0.012464    True2022-08-29 00:02:00    111    -0.033432    -0.006346    False2022-08-29 00:03:00    112    -0.021918    -0.011621    False2022-08-29 00:04:00    111    -0.054992    -0.024523    False...    ...    ...    ...    ...2022-08-29 03:23:00    113    -0.024678    0.008761    False2022-08-29 04:00:00    114    0.141292    0.035267    True2022-08-29 04:01:00    115    0.349447    0.098103    True2022-08-29 04:02:00    112    0.269341    0.132351    True2022-08-29 04:03:00    113    0.283249    0.162530    True100 rows × 4 columnspandas library와 동일한 결과를 얻기 위한 코드가 매우 길어진다. python의 library들이 우리가 코드를 작성하는데 엄청난 편의를 제공하고 있다는 것을 잘 느낄 수 있는 부분이기도 하다.그런데 다음 글에서 소개될 속도 비교를 보면 이 편리한 library도 사용함에 있어서 library를 잘 이해를 하고 적절한 곳에 써야 한다는 것을 알 수 있을 것이다.  실시간 차트의 MACD 지표계산 속도 비교 (pandas vs dictionary)"
  },
  {
    "title": "KT GIGA Wifi 공유기 관리자 모드 접속이 안되는 경우",
    "url": "/posts/kt-giga-connection-error/",
    "categories": "생활정보",
    "tags": "KT GIGA Wifi, 관리자모드 접속 오류, 포트포워딩",
    "date": "2022-08-20 23:31:00 +0900",
    "snippet": "KT GIGA Wifi 접속 오류 CaseKT Giga Wifi 공유기의 경우 homehub.olleh.com나 homehub.kt.com또는 172.30.1.254를 브라우져 주소창에 입력하고 이동하면 관리자 페이지에 접속이 가능하다.엄밀히 말하면 Window키 + R을 눌러 cmd엔터를 쳐주면 나오는 창에 ipconfig를 치고 엔터를 쳐주면 나오는 주소 중 기본게이트웨이의 주소로 접속을 하면 된다.그런데 간혹 아래처럼 기본게이트웨이가 KT공유기 기본설정인 172.30.1.254가 아닌 엉뚱한 주소로 되어 있는 경우가 있다.이 경우는 컴퓨터가 공유기에 연결이 되어 있는 것이 아닌 모뎀에 직접 연결 되어 있기 때문이고 접속을 시도하면 아래와 같은 Error를 띄운다.해결 방법모뎀에 연결된 LAN선을 공유기로 옮겨주면 끝이다.아래의 사진이 모뎀 사진이다. 컴퓨터에 연결된 선을 따라가면 확인이 가능하다.먼지가…모뎀에 연결된 선을 뽑아서 아래 사진처럼 무선안테나가 있는 공유기에 연결해주면 된다.이제 homehub.olleh.com나 172.30.1.254로 접속을 하면 잘 접속이 되는것을 확인 할 수 있다.보안문제 때문에라도 LAN선을 모뎀에 연결 된 채로 두는 것보다 KT Giga Wifi 공유기에 연결을 해 주는것이 좋다.👍"
  },
  {
    "title": "MACD 지표의 고찰",
    "url": "/posts/macd-theory/",
    "categories": "System Trading, 0.Indicators",
    "tags": "macd, indicators, 고찰",
    "date": "2022-08-20 16:56:00 +0900",
    "snippet": "MACD (Moving Average Convergence Divergence) 계산식  MACD = Short_period EMA - Long_period EMAMACD_signal = Signal_period EMA of MACDEMA: Exponential Moving Average      Short_period: 일반적으로 12를 사용    Long_period: 일반적으로 26을 사용    Signal_period: 일반적으로 9를 사용    예로 Short period MA는 최근 12 기간동안의 평균가격을 이야기 한다.다만 여기서는 EMA로 Exponential(지수)라는 단어가 들어가는데 EMA는 새로만들어진 봉에 대한 MA뿐아니라 이미 만들어진 봉의 MA에도 가중치를 주는 방식이다. (자세한 내용은 여기를 클릭 - EMA 지수이동평균 공사중…)MACD는 차트의 종가 기준으로 이동평균을 계산하여 가장 최근의 가격 Trend (Short period EMA)와 장기적인 가격 Trend의 차이를 의미하며, 장기적인 관점에서 가격이 변화하는 것 대비 최근의 가격 변화가 상승 또는 하락을 하고 있는 추세인지 그 추세를 보여주는 지표이다.MACD Crossover보통 MACD Line이 MACD Signal Line을 통과(Crossover)할 때 매수 또는 매도 추세로 진입 했다고 본다.MACD Line이 signal line을 아래에서 위로 뚫고 올라갈땐 골든크로스라고 하며,반대로 위에서 아래로 뚫고 내려갈땐 데드크로스라고 한다.  골든크로스    데드크로스  MACD 단점1.변동성이 약한 횡보장에 약하다MACD는 후행성 추세지표이기 때문에 가격이 한 방향으로 충분히 이동해 주지 않으면 손해를 보기 쉬운 지표이다.손해보는 차트를 하나 예를 들어보겠다.다음의 차트는 최근 나스닥 3분봉 차트 중 일부인데,매수 신호 중 첫번째 노란동그라미만 아주 약간의 수익을 주고 나머지 빨간 동그라미들은 전부 손해다.이처럼 시세가 날듯 말듯 움직이는 횡보 장에서 MACD만으로 거래를 하면 손해가 쌓여 큰 손해로 귀결될 수 있다.2.휩소(whipsaw)에 약하다휩소(whipsaw)는 번역하면 가늘고 긴 톱인데 줄톱정도라 생각하면 상상하기 편한데,톱의 특성상 위로 쓰윽~ 하면 아래로 다시 쑤욱~ 하게 되어 있다.한 마디로 위로 장대양봉을 뽑고 매수신호를 띄운다음 바로 곤두박질 치는 차트를 말한다.이런 경우 MACD 신호가 바닥에서 매수 신호를 띄운경우라면 큰 손해를 보지 않고 넘어갈 수 있으나,만일 매수신호가 장대양봉에서 나온 경우라면 큰 손실을 입을 수 있다.이번에도 나스닥의 3분봉 차트를 예를 들어 아래에 스샷을 올린다.참고로 MACD는 짧은 시간봉에선 횡보장에서 엄청터지고,긴 시간봉에선 휩소에 크게 터질 수 있다…….(그래도 시간봉으로 MACD를 적용 한다면 그나마 횡보장에 덜 터지는 긴 시간봉이 나은것 같다.)아니 그럼 도데체 MACD라는 지표는 왜 개발되었고 왜 쓰는건가 싶을 것이다.당연하듯 단점이 있으면 장점이 있고, 단점을 보완할 방법도 있다.우선 장점에 대해서 알아보자.MACD 장점위의 단점에도 불구하고 MACD가 유명하고 많이 언급되는 이유가 있고 이에 대해 알아보려 한다.MACD는 가격이 한방향으로 추세가 잘 나거나 가격 변동폭이 큰 스윙을 하는 경우에 빛을 발한다.이번엔 이더리움의 1시간봉이다.아래의 그래프를 보면 2,278,000원에 진입해서 2,503,000원에 나온다.거의 10% 수익이다!이렇듯 추세가 잘 나와줘서 큰 시세가 날 경우 MACD는 큰 수익을 안겨다 줄 수 있다.다만, 중요한 점은 그냥 MACD만 돌리게 되면 수익과 손해를 반복하다 결국 그냥 거의 100% 손해다.그럼 이런 생각을 해 볼 수 있다 \"만약 MACD의 단점을 보완할 무언가가 있으면 수익을 낼 수 있겠네?\"해서 많은 보조지표들이 개발되어 있고 보완 할 수 있는 지표를 소개해 보려한다.1.변동성이 약한 횡보장의 단점 보완:  ATR이라는 상대적인 변동성을 측정하는 지표가 있는데,이 지표가 변동성이 높다고 신호를 띄울 때 MACD를 쓰는 방법이 단점을 보완하는 방법 중 하나이다.만일 ATR이 완벽하게 변동성을 예측할 수 있다면 MACD로 큰 수익을 낼 수 있게 될 것이고 만능 지표가 될 것이나,애초에 예측이란 것은 확률의 문제일 뿐 완벽한 것이 아니다.실제로 돌려보면 이것도 손해를 많이 볼 것이다.하지만, 그냥 MACD를 돌리는 것 보다는 좋은 결과를 얻을 수 있을 것이다.ATR에 대한 자세한 내용을 우측의 링크를 클릭: (링크: 공사중)2.휩소(whipsaw)에 약한 점 보완:  시간 봉의 단점이 바로 휩소이다.설정한 시간동안에 봉이 만들어지는데 그 시간동안의 가격 움직임의 중간 과정을 봉 하나로 표현하기 때문이다.이를 보완하기 위해서 틱(tick)차트라는 것이 있는데, 1 틱(tick)이란 체결된 1개의 거래를 말한다.예를들어 10틱 차트가 있다고 가정을 하면 시간과 무관하게 10번의 거래가 체결이 되면 10틱차트의 봉 1개가 만들어진다.틱차트는 시간과 무관하고 거래가 체결되어야 가격이 움직이기 때문에 휩소 차트가 거의 나오지 않는다.물론 이 틱차트 조차도 절대로 완전한 해결책이 아니다.틱차트에 대한 내용은 우측의 링크를 클릭: (링크: 공사중)변동성이 약한 장에서의 단점을 보완하기 위해 변동성 지표라는 ATR을 MACD와 같이 쓰는 것휩소를 보완하기 위해 틱 차트를 보는것들은 단점에 기인한 아이디어 일 뿐이다.절대로 완벽한 해답이 될 수 없다.이런식으로 여러 지표들의 장/단점, 보완책, 대책 등을 연구하고지표의 Parameter들을 수정해보거나 식자체를 Customizing하는 방법등을 사용하여자신에게 맞는 지표들로 자신에게 맞는 자신만의 투자스타일을 찾아 보길 바란다.MACD Testing아래는 Trading wiew에서 제공하는 이더리움의 차트이다.MACD 지표가 있어 직관적인 Test를 해 볼 수 있으니 이것저것 하다보면 MACD지표에 대한 이해도가 높아질 것이다.    ETH Chart by TradingView    System Trading을 하려면 MACD를 계산하는 코드를 작성해 볼 필요가 있다.그래서 python에서 가장 유명한 data분석 library인 pandas를 이용한 방법과python의 기본 dictionary를 활용한 방법을 알아보려 한다.두 가지 방법을 다 알아보는 이유는 여기에도 역시 장단점이 존재하기 때문이다.  MACD의 python code 작성에 대해 알아보려면 아래의 링크를 참조 바란다.https://pioneergu.github.io/posts/macd-code/"
  },
  {
    "title": "KT GIGA Wifi 포트포워딩",
    "url": "/posts/kt-portforwarding/",
    "categories": "생활정보",
    "tags": "kt giga, portforwarding, 포트포워딩",
    "date": "2022-08-19 13:11:00 +0900",
    "snippet": "포트포워딩 (Port Forwarding)외부 망에서 공유기를 지나 내 컴퓨터에 접속하게 하기 위해서는 포트포워딩이란 것을 해 줘야 한다.내 컴퓨터 원격접속을 하거나 내 컴퓨터에 마인크래프트와 같은 게임의 서버(e.g.포지서버)를 열어서 외부 사용자가 개인서버에 접속해 멀티플레이를 하는 경우가 대표적인 예이다.포트포워딩을 하는 방법은 집에 설치된 공유기마다 다른데 여기서는 KT GIGA Wifi 공유기 기준으로 방법을 설명하려 한다.  참고: ipTIME 공유기 포트포워딩 방법: https://pioneergu.github.io/posts/iptime-portforwarding/KT공유기 관리자 페이지 접속KT Giga Wifi 공유기의 경우 homehub.olleh.com, homehub.kt.com나 172.30.1.254를 브라우져 주소창에 입력하고 이동하면 관리자 페이지에 접속이 가능하다.만일 아래처럼 사이트에 연결할 수 없음, 172.30.1.254에서 응답하는 데 시간이 너무 오래 걸립니다.라는 메세지가 뜬다면KT GIGA Wifi 관리자 모드 접속이 안되는 경우 에 해결방법이 있으니 참고 바란다.  id: ktuserpw: homehub (또는 megaap)처음 접속을 하게 되면 id와 비밀번호를 꼭 변경하게 되어 있는데 이를 잘 적어두지 않으면 나중에 찾기 힘들다…만일 id와 비밀번호를 잊었다면, 공유기 본체 측면에 초기화버튼을 뾰족한걸로 5초정도 누르면 id와 비밀번호가 초기화 된다.로그인을 하게 되면 아래와 같은 화면이 나오게 되는데 장치설정 &gt; 트래픽관리 &gt; 포트포워딩으로 들어가준다.  내부 IP 주소: 나의 내부 IP주소를 적어준다. 내 IP주소 확인하는 방법-클릭외부포트: 마크서버를 열기 위해선 25565를 적는다.      참고로, 일반적인 경우는 1~65535의 숫자가 가능한데 보통 100미만의 숫자는 미리 할당되어 있다고 하므로 좀 큰숫자를 적기를 권장한다.    내부포트: 25565로 외부포트와 같은 번호를 준다.      다만 참고로 원격접속을 목적으로 포트포워딩을 하는 경우 내부포트를 3389로 해줘야 한다.    주의할점은 원격접속기능을 사용하기 위해 내/외부 포트를 모두 3389로 해주면 잘 알려진 숫자이므로 보안에 취약할 수 있게된다.    따라서, 원격 사용 시 외부포트 12345, 내부포트 3389 이런식으로 다르게 해 주는 것이 좋다.    프로토콜: TCP로 그대로 둔다. 설명: 적당한 이름을 적어준다.입력을 해 주고 추가버튼을 눌러주면 아래처럼 추가가 된다.외부에서 접속이제 외부에서 접속하려면 나의 외부 IP주소에 :을 붙이고 외부포트번호를 적어서 123.123.123.123:12345 이런식으로 적어서 접속하면 된다.아래에 외부 IP주소가 있으니 참조하면 된다.  당신의 외부 IP주소는: Loading IP Address... 입니다.포트포워딩 테스트친구에게 IP주소를 알려주기전에 포트포워딩이 잘 되고 있는지 확인을 해보도록 하자.앞에서 만든 롤러코스터 서버 폴더의 StartServer.bat파일을 실행해 서버를 실행한다.서버를 실행 한 후 아래의 주소로 들어가 보자.  포트포워딩 테스트: https://www.yougetsignal.com/tools/open-ports/포트포워딩 테스트 사이트에 들어가면 외부 IP주소가 자동으로 입력이 되어 있을것이다.지정해준 외부포트번호인 25565를 Port Number에 입력하고 엔터를 누르면,아래와 같이 초록색 깃발과 함께 Port 25565 is open on [외부IP주소]라는 문구가 뜨면 성공한 것이다!이제 친구에게 나의 외부IP주소:25565를 알려주고,집에서 친구와 마인크래프트 모드를 온라인으로 즐기자~!👏"
  },
  {
    "title": "포지 서버 (forge server)열기, 마인크래프트 자바 온라인플레이",
    "url": "/posts/minecraft-forge-server/",
    "categories": "마인크래프트",
    "tags": "ex roller coaster, minecraft java, 도티tv, 마인크래프트 자바, 초현실 롤러코스터, 포지모드, 포지서버열기, 온라인, 멀티플레이",
    "date": "2022-08-18 20:21:00 +0900",
    "snippet": "포지모드(Forge Mod) 온라인 플레이를 위한 포지서버(Forge Server) 열기저번에 설치한 초현실 롤러코스터 모드인 EX Roller Coaster Mod 를 친구랑 같은 공유기환경이 아닌 각자의 집에서 온라인으로 접속해 함께 즐길 수 있는 방법에 대해서 알아보자.포지 모드 게임을 온라인으로 플레이하려면 누군가 한 명이 포지 서버를 열어야 한다.우선 서버의 종류부터 알아보자.0. 서버 종류  공식 서버: 플러그인이나 모드 적용이 되지 않는 서버 구축 가능.      마인크래프트 Java Edition 공식 서버 구축: https://www.minecraft.net/ko-kr/download/server    아래의 버킷은 플러그인 적용이 가능하나 모드는 적용이 안 되는 서버를 구축 가능.      크래프트 버킷: https://getbukkit.org/download/craftbukkit호환성 높고 가장 많이 사용한다고함.    스피곳 버킷: https://getbukkit.org/download/spigot크래프트 버킷과 양대 산맥이라고함.    페이퍼MC 버킷: https://papermc.io/downloads안정성 및 호환성 좋음    아래는 모드 적용이 가능한 서버 구축 가능. (모드를 사용하려면 포지가 필요함)      스폰지 포지 (전용플러그인 사용): https://spongepowered.org/downloads/spongeforge    포지 (기본, 플러그인 사용 불가): https://files.minecraftforge.net/net/minecraftforge/forge/    여기선 기본 포지(forge)로 서버 구축을 해보려 한다.1. Java 설치우선 자바를 설치해야 하는데 자바에는 JRE(Java Reutime Environment)가 있고, JDK(Java Development Kit)이 있다.간단히 얘기해서 JRE는 자바로 만들어진 프로그램을 실행만 하는 것이고, JDK는 JRE에 개발도구들이 추가된 것이라고 생각하면 되는데, 마인크래프트 모드(포지) 서버를 돌리기 위해서는 JRE가 필요하다.  (페이퍼 버킷 같은경우 JDK를 요구하고, 포지 같은경우는 JDK가 설치되어 있음 안 된다.이런식으로 서비스 제공자마다 다를 수 있으니 참고 바란다.)  자바 JRE 다운로드 페이지: https://www.java.com/ko/download/manual.jsp위의 링크로 들어가보면 아래의 스샷처럼 여러 옵션이 나오게 되는데 WINDOWS 오프라인 (64비트)를 선택하자.64비트를 선택해야 서버에 높은 메모리를 할당해 줄 수 있다.  설치를 눌러 설치를 진행해 주면 되는데 구버젼의 자바가 설치되어 있는 경우 설치 해제를 권장하는 문구가 뜨는데,꼭 설치해제를 해주도록 하자!!!2. 포지(forge)를 서버모드로 설치  포지(forge) 다운로드 페이지: https://files.minecraftforge.net/net/minecraftforge/forge/앞서 설치한 초현실 롤러코스터 forge 버젼과 같은 버젼인 1.7.10을 선택해서 서버를 구축하려한다.포지 홈피의 좌측에서 내가 원하는 버젼을 선택한 후Download Recommended의 Installer를 눌러준다.Installer를 누르면 광고화면이 나오게 되는데 우측상단에 아래와 같이 뜨게되고잠시 기다려서 SKIP 버튼이 뜨면 눌러준다그럼 자동으로 다운로드가 되고 아래와 같은 파일이 다운로드 폴더에 받아지게 된다.다운 받아진 파일을 실행하면 아래와 같은 창이 뜨는데 Install Sever를 클릭해 주고,...을 눌러서 설치폴더를 서버를 운영할 폴더로 바꿔줘야 한다.내 경우에는 바탕화면에 롤러코스터서버라는 폴더를 만들어 그곳으로 지정해 주었다.OK를 눌러 설치를 완료하면 설치를 하라고 지정해 준 롤러코스터 폴더에 아래처럼 새로운 파일들이 생성된 것을 알 수 있다.3. 포지(forge) 서버 실행해당 폴더의 빈 곳에 마우스 우클릭을 하고 새로만들기 &gt; 텍스트 문서를 클릭하면 새 텍스트 문서가 생성된다.생성된 새 텍스트 문서의 현재 확장자는 .txt 파일인데 스크립트를 실행해 줄 수 있는 배치파일인 .bat 파일로 바꿔줘야 한다.그러기 위해서는 탐색기 상단의 보기를 클릭하고 파일확장명을 체크해 준다.그럼 이제 파일의 확장자명이 보이게 된다.F2버튼을 누르거나 마우스 우클릭으로 이름 바꾸기를 클릭하여 적당한 이름의 .bat파일로 바꿔준다.나는 StartSever.bat정도로 정하였다.그런 후 StartSever.bat파일에 마우스 우클릭을 하여 편집을 눌러준다.편집을 누르면 텍스트 에디터가 뜨게 되는데,  여기에 java -Xms1G -Xmx2G -jar [파일명]를 적어주고,다음 줄에 pause를 적어주고 저장을 하고 나가준다.-Xms1G는 메모리를 최소 1기가를 쓴다는 것이고-Xmx2G는 메모리를 최대 2기가를 쓴다는 것이다.참고로, 친구들이랑 즐기는 용도면 2기가면 충분하다.  이제 만들어준 StartServer.bat파일을 더블클릭하여 실행해 준다.(실행 오류 시 참고사항)  만일 java jdk가 설치되어 있다면 아래와 같은 오류를 띄우며 실행이 되지 않는다.이런 경우 포지모드 서버를 구축하려면 jdk를 지워야 한다.C:\\Users\\pyoneer\\Desktop\\롤러코스터서버&gt;java -Xms1G -Xmx2G -jar forge-1.7.10-10.13.4.1614-1.7.10-universal.jarA problem occurred running the Server launcher.java.lang.reflect.InvocationTargetException        at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:110)        at java.base/java.lang.reflect.Method.invoke(Method.java:577)        at cpw.mods.fml.relauncher.ServerLaunchWrapper.run(ServerLaunchWrapper.java:43)        at cpw.mods.fml.relauncher.ServerLaunchWrapper.main(ServerLaunchWrapper.java:12)Caused by: java.lang.ClassCastException: class jdk.internal.loader.ClassLoaders$AppClassLoader cannot be cast to class java.net.URLClassLoader (jdk.internal.loader.ClassLoaders$AppClassLoader and java.net.URLClassLoader are in module java.base of loader 'bootstrap')        at net.minecraft.launchwrapper.Launch.&lt;init&gt;(Launch.java:34)        at net.minecraft.launchwrapper.Launch.main(Launch.java:28)        at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)        ... 3 moreC:\\Users\\pyoneer\\Desktop\\롤러코스터서버&gt;pause계속하려면 아무 키나 누르십시오 . . .JDK를 지우려면 아래의 것을 지워주면된다.JDK를 지우고 다시 StartServer.bat를 실행 하면 또 다음과 같은 메세지를 띄우며 종료가 된다.[12:09:52] [Server thread/WARN]: Failed to load eula.txt[12:09:52] [Server thread/INFO]: You need to agree to the EULA in order to run the server. Go to eula.txt for more info.[12:09:52] [Server thread/WARN] [FML]: Can't revert to frozen GameData state without freezing first.[12:09:52] [Server thread/INFO] [FML]: Applying holder lookups[12:09:52] [Server thread/INFO] [FML]: Holder lookups applied[12:09:52] [Server thread/INFO] [FML]: The state engine was in incorrect state POSTINITIALIZATION and forced into state SERVER_STOPPED. Errors may have been discarded.C:\\Users\\pyoneer\\Desktop\\롤러코스터서버&gt;pause계속하려면 아무 키나 누르십시오 . . .잘 읽어보면 EULA에 동의를 해야 Sever를 이용할 수 있다고 한다.EULA는 End-User License Agreement의 약자로 최종사용권자의 라이센스 동의인데간단히 마인크래프트 이용규정이라고 보면 된다.동의를 하지 않으면 사용이 불가능하니 동의를 해주도록 하자.서버가 설치된 폴더를 보면 eula.txt파일이 생성된 것을 확인 할 수 있다.이 파일을 열고, eula=false를 eula=true로 바꿔주자.서버가 실행되는 중간에 아래와 같은 문구가 뜰 수 있는데 허용을 눌러주면된다.콘솔창에 아래처럼 Done이라는 메세지가 뜨면 서버가 잘 실행 된 것이다.[12:35:08] [Server thread/INFO] [FML]: Loading dimension 0 (world) (net.minecraft.server.dedicated.DedicatedServer@18387357)[12:35:08] [Server thread/INFO] [FML]: Loading dimension 1 (world) (net.minecraft.server.dedicated.DedicatedServer@18387357)[12:35:08] [Server thread/INFO] [FML]: Loading dimension -1 (world) (net.minecraft.server.dedicated.DedicatedServer@18387357)[12:35:08] [Server thread/INFO]: Preparing start region for level 0[12:35:09] [Server thread/INFO]: Preparing spawn area: 7%[12:35:10] [Server thread/INFO]: Preparing spawn area: 20%[12:35:11] [Server thread/INFO]: Preparing spawn area: 39%[12:35:12] [Server thread/INFO]: Preparing spawn area: 65%[12:35:13] [Server thread/INFO]: Preparing spawn area: 90%[12:35:13] [Server thread/INFO]: Done (6.579s)! For help, type \"help\" or \"?\"이제 다운받은 EX Roller Coaster Mod를 서버가 설치된 폴더안의 mods에 넣어주면 된다.초현실 롤러코스터 모드 설치 시 넣은 C:\\Users\\[유저이름]\\AppData\\Roaming\\.minecraft\\mods 에서 복사해 오자.window키 + R을 눌러 %appdata%를 치면 해당 폴더로의 접근이 쉽다.참고로, 접속하려는 친구의 마인크래프트에 같은 모드가 설치되어 있어야하고,접속하려는 서버에도 같은 모드가 설치되어 있어야 멀티플레이 게임이 가능하다.이제 다음으로 친구들이 내 서버로 접속 할 수 있게 포트포워딩 하는 방법을 알아보려 한다.  공유기가 KT GIGA 일 경우https://pioneergu.github.io/posts/kt-portforwarding/  공유기가 ipTME일 경우https://pioneergu.github.io/posts/iptime-portforwarding/"
  },
  {
    "title": "ipTIME 포트포워딩",
    "url": "/posts/iptime-portforwarding/",
    "categories": "생활정보",
    "tags": "iptime, portforwarding, 포트포워딩",
    "date": "2022-08-18 17:21:00 +0900",
    "snippet": "포트포워딩 (Port Forwarding)외부 망에서 공유기를 지나 내 컴퓨터에 접속하게 하기 위해서는 포트포워딩이란 것을 해 줘야 한다.내 컴퓨터 원격접속을 하거나 내 컴퓨터에 마인크래프트와 같은 게임의 서버(e.g.포지서버)를 열어서 외부 사용자가 개인서버에 접속해 멀티플레이를 하는 경우가 대표적인 예이다.포트포워딩을 하는 방법은 집에 설치된 공유기마다 다른데 여기서는 ipTIME 공유기 기준으로 방법을 설명하려 한다.  참고: KT GIGA Wifi 공유기 포트포워딩 방법: https://pioneergu.github.io/posts/kt-portforwarding/iptime 관리자 페이지 접속하기브라우저 주소창에 192.168.0.1을 입력하면 아래와 같이 로그인 이름과 암호를 요구하는데,초기값은 admin/admin이다.(보안을 위해 관리자페이지에서 바꿔주는 것이 좋다)iptime-login]iptime-login로그인을 하면 아래와 같은 화면이 나오는데 관리도구를 클릭해 준다.(참고로, 스샷에 표시된 것처럼 나의 외부 IP주소를 보여준다)포트포워드 설정관리도구에 들어가면 아래와 같은 메뉴가 나타난다.좌측 메뉴탐색기에서 고급설정 &gt; NAT/라우터 관리 &gt; 포트포워드 설정을 클릭한다.      규칙이름: 나중에 핵갈리지 않게 적당한 이름을 정해 준다.    내부IP주소: 현재 접속된 IP주소 앞에 체크박스를 클릭해주면 된다.    프로토콜: TCP 그대로 둔다.    외부포트: 1~65535의 숫자가 가능한데 보통 100미만의 숫자는 미리 할당되어 있다고 하므로 좀 큰숫자를 적기를 권장한다. (마인크래프트 서버 구축을 위한 경우는 25565를 적어준다.)    내부포트: 내부적으로 사용하는 포트번호로 적당한 번호를 주면 되는데 외부포트번호와 같은 번호를 해도 된다. (마인크래프트 서버 구축을 위한 경우는 25565를 적어준다.)    다만 참고로 원격접속을 목적으로 포트포워딩을 하는 경우 내부포트를 3389로 해줘야 한다.주의할점은 원격접속기능을 사용하기 위해 내/외부 포트를 모두 3389로 해주면 잘 알려진 숫자이므로 보안에 취약할 수 있게된다.따라서, 원격 사용 시 외부포트 12345, 내부포트 3389 이런식으로 다르게 해 주는 것이 좋다.외부에서 접속이제 외부에서 접속하려면 나의 외부 IP주소에 :을 붙이고 외부포트번호를 적어서 123.123.123.123:12345 이런식으로 적어서 접속하면 된다.아래에 외부 IP주소가 있으니 참조하면 된다.  당신의 외부 IP주소는: Loading IP Address... 입니다.마인크래프트 포지서버 포트포워딩 테스트친구에게 IP주소를 알려주기전에 포트포워딩이 잘 되고 있는지 확인을 해보도록 하자.앞에서 만든 롤러코스터 서버 폴더의 StartServer.bat파일을 실행해 서버를 실행한다.서버를 실행 한 후 아래의 주소로 들어가 보자.  포트포워딩 테스트: https://www.yougetsignal.com/tools/open-ports/포트포워딩 테스트 사이트에 들어가면 외부 IP주소가 자동으로 입력이 되어 있을것이다.지정해준 외부포트번호인 25565를 Port Number에 입력하고 엔터를 누르면,아래와 같이 초록색 깃발과 함께 Port 25565 is open on [외부IP주소]라는 문구가 뜨면 성공한 것이다!이제 친구에게 나의 외부IP주소:25565를 알려주고,집에서 친구와 마인크래프트 모드를 온라인으로 즐기자~!👏끝~"
  },
  {
    "title": "Python - Requests를 이용한 File download",
    "url": "/posts/tick-data-download/",
    "categories": "System Trading, 1.Data Crawling",
    "tags": "crypto currency, btc, eth, bitcoin, tick data, selenium, web crawling, requests",
    "date": "2022-08-15 21:05:00 +0900",
    "snippet": "Requests 설치앞에서 동적 웹크롤링으로 Tick data를 다운로드 할 수 있는 Link를 얻었다.이제 그 Link를 Requests를 이용해서 File을 다운로드 해보자.Requests 라이브러리를 설치한다.pip install requestsRequests를 이용한 File Download 함수 만들기코인들의 Tick data link들을 list형태로 얻었으니,이제 requests library를 사용하여 file을 다운로드 할 차례다!우선 file을 저장할 path를 결정하고 해당 폴더를 만들고 file path를 얻는 함수를 만들고,requests를 이용한 download 함수를 만들자.import osdef make_save_path(folder_path):    \"\"\"    try make folder to save files.    if folder exists, passed by exception.    \"\"\"    try:        os.mkdir(folder_path)  # 폴더를 만드는 것을 시도한다.    except:        pass  # 이미 해당 폴더가 있을 경우 예외처리하여 passdef get_save_path(folder_path, file_name):    return folder_path + file_name  # 저장할 폴더와 File명을 path로 returndef download(file_path, url):    with open(file_path, 'wb') as file:  # write binary 모드로 열기        response = requests.get(url)  # url 요청결과 얻기        file.write(response.content)  # file에 쓰기Requests File Download Test함수가 완성되었으니 이제 Coin의 tick data file link list를 얻는 코드를 함께 사용하여,link list의 첫번째 link만 다운로드 하여 테스트를 해보자.# Bitmex 에서 Data 받기from selenium import webdriverimport requestsimport osdef get_url_links(url, driver_path=None, ext=''):    if driver_path:        driver = webdriver.Chrome(driver_path)  # Webdriver의 경로를 지정하는 경우    else:        driver = webdriver.Chrome()  # 코드파일과 같은 폴더에 Webdriver가 있는 경우    driver.implicitly_wait(10)    # 지정된 시간인 10초 안에 페이지의 로딩이 끝나면 다음으로 넘어감.    # 지정된 시간 안에 로딩이 완료되지 않으면 Error띄움.    driver.get(url)    element_id = driver.find_element_by_id('listing')    pre_tag = element_id.find_element_by_tag_name('pre')    a_tags = pre_tag.find_elements_by_tag_name('a')  # a tag list를 얻음.    links = []    for a_tag in a_tags:        link = a_tag.get_attribute('href')  # href의 link 주소 얻음.        if link.endswith(ext):  # 확장자가 gz 인 link만 links에 append.            links.append(link)    return linksdef make_save_path(folder_path):    \"\"\"    try make folder to save files.    if folder exists, passed by exception.    \"\"\"    try:        os.mkdir(folder_path)    except:        passdef get_save_path(folder_path, file_name):    return folder_path + file_namedef download(file_path, url):    with open(file_path, 'wb') as file:  # write binary 모드로 열기        response = requests.get(url)  # url 요청결과 얻기        file.write(response.content)  # file에 쓰기if __name__ == '__main__':    url = \"https://public.bitmex.com/?prefix=data/trade/\"    ext = 'gz'    driver_path = '.\\\\chromedriver.exe'    save_path = '.\\\\db\\\\'    url_links = get_url_links(url, driver_path, ext)    make_save_path(save_path)    file_name = url_links[0].split('/')[-1]  # /로 str을 split하여 file name만 따로 분리    file_path = get_save_path(save_path, file_name)    download(file_path, url_links[0])첫 번째 tick data가 잘 저장된 것을 확인 할 수 있다.Requests File Download이제 코인들의 나머지 tick data 전부를 받아 보자.그런데, 잘 보면 get_url_links함수 안에서 for a_tag in a_tags: line에서 for 문이 이미 돌아가니함수 바깥에서 for문을 또 돌려서 다운로드 하는 낭비를 막기 위해get_url_links함수의 for문에서 직접 다운로드 하는 코드로 수정을 해 보겠다.# Bitmex 에서 Data 받기from selenium import webdriverimport requestsimport osdef download_files_on_url(url, save_path='', driver_path=None, ext=''):    if driver_path:        driver = webdriver.Chrome(driver_path)  # Webdriver의 경로를 지정하는 경우    else:        driver = webdriver.Chrome()  # 코드파일과 같은 폴더에 Webdriver가 있는 경우    driver.implicitly_wait(10)    # 지정된 시간인 10초 안에 페이지의 로딩이 끝나면 다음으로 넘어감.    # 지정된 시간 안에 로딩이 완료되지 않으면 Error띄움.    driver.get(url)    element_id = driver.find_element_by_id('listing')    pre_tag = element_id.find_element_by_tag_name('pre')    a_tags = pre_tag.find_elements_by_tag_name('a')  # a tag list를 얻음.    links = []    for a_tag in a_tags:        link = a_tag.get_attribute('href')  # href의 link 주소 얻음.        if link.endswith(ext):  # 확장자가 gz 인 link만 links에 append.            file_name = link.split('/')[-1]            file_path = get_save_path(save_path, file_name)            download(file_path, link)def make_save_path(folder_path):    \"\"\"    try make folder to save files.    if folder exists, passed by exception.    \"\"\"    try:        os.mkdir(folder_path)    except:        passdef get_save_path(folder_path, file_name):    return folder_path + file_namedef download(file_path, url):    with open(file_path, 'wb') as file:  # write binary 모드로 열기        response = requests.get(url)  # url 요청결과 얻기        file.write(response.content)  # file에 쓰기if __name__ == '__main__':    url = \"https://public.bitmex.com/?prefix=data/trade/\"    ext = 'gz'    driver_path = '.\\\\chromedriver.exe'    save_path = '.\\\\db\\\\'    make_save_path(save_path)    download_files_on_url(url, save_path, driver_path, ext)    # 역할에 맞게 함수명 수정.4시간 넘게 기다리니 40 기가에 달하는 2,823개의 tick data가 다운 받아졌다…이거 아무래도 다음에 또 이런걸 받을일이 생기면 동시성 코드를 짜서 한꺼번에 여러개를 다운로드 받을 수 있게 해야겠다.from selenium import webdriverdef get_url_links(url, driver_path=None, ext=''):    if driver_path:        driver = webdriver.Chrome(driver_path)  # Webdriver의 경로를 지정하는 경우    else:        driver = webdriver.Chrome()  # 코드파일과 같은 폴더에 Webdriver가 있는 경우    driver.implicitly_wait(10)    # 지정된 시간인 10초 안에 페이지의 로딩이 끝나면 다음으로 넘어감.    # 지정된 시간 안에 로딩이 완료되지 않으면 Error띄움.    driver.get(url)    element_id = driver.find_element_by_id('listing')    pre_tag = element_id.find_element_by_tag_name('pre')    a_tags = pre_tag.find_elements_by_tag_name('a')  # a tag list를 얻음.    links = []    for a_tag in a_tags:        link = a_tag.get_attribute('href')  # href의 link 주소 얻음.        if link.endswith(ext):  # 확장자가 gz 인 link만 links에 append.            links.append(link)    return linksif __name__ == '__main__':    url = \"https://public.bitmex.com/?prefix=data/trade/\"    ext = 'gz'    driver_path = '.\\\\chromedriver.exe'    url_links = get_url_links(url, driver_path, ext)    print(len(url_links))2823a tag의 file link list의 length를 확인해 보면 위의 결과처럼 2,823개로 데이터가 빠짐없이 다운로드 된 것을 알 수 있다. 👌"
  },
  {
    "title": "내 IP주소 확인! (바로 확인가능)",
    "url": "/posts/my-external-ip/",
    "categories": "생활정보",
    "tags": "IP주소, external IP",
    "date": "2022-08-15 15:24:00 +0900",
    "snippet": "내 아이피주소(IP address) 직접 확인!아래의 주소가 현재 이 글을 보시는 분이 사용중인 컴퓨터의 IP주소(External IP)이다.  당신의 IP주소는: Loading IP Address... 입니다.추가로 검색포털을 활용하여 IP 주소를 확인 할 수 있다~아래에 그 내용이 있다.검색포털 활용 (외부 IP주소)네이버든 다음이든 검색포털에 내 IP주소 또는 내아이피라고 치면 아래처럼 나의 외부 ip주소를 알려준다.외부에서 접속할 때 필요한 IP주소이다.  지금까지는 외부 IP주소(External IP)를 조회 하는 방법에 대해 알아보았는데 공유기 환경에서는 내부적으로 사용하는 내부 IP(Private IP)가 따로 있다.이번엔 내부 IP(Private IP)에 대해서 알아보자.Private IP주소 (내부 IP주소)컴퓨터에서 IP주소를 확인하는 방법이 있다.(cmd -&gt; ipconfig)이 방법은 컴퓨터가 할당 받은 IP주소를 보는 방법이다.  컴퓨터가 공유기에 연결된 경우:      여러대의 컴퓨터가 연결이 되는 공유기 특성상 컴퓨터를 구별하기 위한 방법이 필요하다.  때문에 공유기가 임의로 뿌려준 내부 IP정보를 얻는 방법이다.    컴퓨터가 모뎀에 직접 연결된 경우:      만일 컴퓨터가 모뎀에 직접 연결이 되어 있을때는 내부IP가 곧 외부IP가 되므로 외부 IP주소를 얻을 수가 있다.  하지만 컴퓨터가 공유기에 연결이 되어 있는 경우라면, 아래의 방법으로는 외부 IP주소를 얻을 수가 없다.따라서, 본 글 상단에 표시된 IP주소나, 포털사이트 검색을 통해 얻는 IP주소가 외부에서 접근가능한 내 공인 IP주소가 된다.내부 IP주소 확인법Window키 + r버튼을 누르면 아래와 같은 창이 뜨는데 여기에 cmd를 적어준다.그러면 아래와 같은 검은 창이 뜨는데 여기에 ipconfig를 쳐준다.여기 나오는 숫자중 IPv4주소가 내부 IP주소가 된다.끝~!😁"
  },
  {
    "title": "미성년자 통장개설 시 필요서류 및 발급 방법 (생활정보)",
    "url": "/posts/bank-docs-for-minor/",
    "categories": "생활정보",
    "tags": "미성년자, 통장개설, 서류, 기본증명서 발급, 가족관계등록부 발급",
    "date": "2022-08-11 12:24:00 +0900",
    "snippet": "미성년자 통장개설 시 필요한 서류들이번에 아이들 명의로 용돈 통장을 만들어 주는데필요 서류 부족으로 은행을 두 번 방문했다. 😢또 이런일이 일어나지 않도록 미성년자 명의로 통장개설 시 필요한 서류를 정리해 놓으려 한다.1. 상세 기본증명서 (미성년자 기준)✔ 미성년자의 기본증명서를 상세로 뗀다.2. 가족관계 증명서 (주민번호 기재 / 내방고객 기준)✔ 법정대리인인 부모의 기준으로 가족관계 증명서를 뗀다. 주민번호 모두 표시!!3. 내방고객(법정대리인) 신분증✔ 부모의 신분증 지참 필!4. 통장사용 인감✔ 미성년자의 통장에 사용할 도장도 필요하다~필요한 서류는 확인 했으니 이제 서류의 발급 방법을 알아 보자.기본증명서(상세) 및 가족관계등록부 발급 방법기본증명서(상세) 미성년자 기준 발급기본증명서(상세)는 미성년자 기준으로 떼야하는데 그 방법에 대해 알아보겠다.전자가족관계등록시스템 홈페이지에 접속하면 아래와 같은 화면이 보일 것이다.여기서 기본증명서를 클릭하여 약관동의 및 인증서로그인을 한다.  아래와 같이 증명서를 출력하는 옵션이 여러가지가 있는데 하나씩 알아보자.1. 발급대상자: 가족을 선택하고 통장을 발급받을 자녀(미성년자)를 선택한다.2. 증명서 종류: 증명서 종류는 기본증명서이다.3. 일반,상세,특정: 상세증명서를 선택한다.4. 주민등록번호(뒷 6자리) 공개여부: 가족관계등록부에서 주민번호 공개를 하기 때문에 요구사항은 아니나, 혹시모르니 전부 공개로 하자~5. 수령방법: 직접인쇄나, 전자문서지갑을 선택해서 사용한다.6. 신청사유: 국내 은행(기관)에 제출하니 국내 기관 제출을 선택하자.신청하기 버튼을 클릭하면 증명서의 출력이 가능한 화면이 나온다.가족관계등록부 발급가족관계등록부는 법정대리인인 부모 기준으로 발급해야 하며 주민등록번호를 뒷부분 6자리 모두 공개를 해서 발급 받야아 한다.아래처럼 선택을 해 준 후 신청하기 버튼을 누르면 마찬가지로 발급받은 가족관계등록부를 출력 할 수 있다.참고로 인터넷 발급은 무료이다.이제 출력한 기본증명서(상세)와 가족관계등록부 그리고 신분증과 아이의 도장을 챙겨서 은행으로 가자!"
  },
  {
    "title": "Python - Selenium 암호화폐 Tick Data 동적 웹 크롤링",
    "url": "/posts/tick-data-selenium/",
    "categories": "System Trading, 1.Data Crawling",
    "tags": "crypto currency, btc, eth, bitcoin, tick data, selenium, web crawling",
    "date": "2022-08-09 22:48:00 +0900",
    "snippet": "BitMex 과거 Raw Tick DataSystem Trading 시 시간 봉(차트)로 거래를 하면 소위말하는 휩소(whipsaw: 가늘고 긴 톱)에 당하기 쉽다.그래서 Tick 차트를 활용하는 것이 좋은데, Tick 차트를 만들려면 Tick Data가 필요하다.이것 저것 검색을 하다 보니 BitMex에서 비트코인 및 코인들의 Tick Data를 제공하고 있다는 것을 알게 되었다.  BitMex 과거 Tick Data - Link위 주소에 접속을 해 보면 아래 처럼 2014년 11월 부터 어제까지의 Data가 List-up되어 있는 것을 볼 수 있다.이 자료를 수동을 받으려면 몇 일이 걸릴지… 이런 작업이 또 생긴다면?…그래서 동적 웹 크롤링 (Crawling)을 사용하려 한다.정적 웹 크롤링 (request, beautifulsoup)의 한계웹 크롤링을 하기 전에 크롤링을 하려는 웹 페이지의 구성을 보면,이 처럼 listing 이라는 id로 된 div tag 하위의 pre tag 안에 a tag로 link가 걸려 있다.a tag의 href에 적힌 수많은 파일들의 링크 주소를 얻어야 tick data를 다운 받을 수 있다.주소를 얻기 위해서 우선 requests 를 사용하여 위에 링크된 Raw tick data가 있는 Page를 확인 해 보겠다.import requestsdef download(url):    page = requests.get(url).text    print(page)if __name__ == '__main__':    url = \"https://public.bitmex.com/?prefix=data/trade/\"    download(url)&lt;body&gt;  &lt;div id=\"navigation\"&gt;&lt;/div&gt;  &lt;div id=\"listing\"&gt;&lt;/div&gt;  &lt;script type=\"text/javascript\"    src=\"https://public.bitmex.com/jquery.min.js\"    integrity=\"sha384-3ceskX3iaEnIogmQchP8opvBy3Mi7Ce34nWjpBIwVTHfGYWQS9jwHDVRnpKKHJg7\"    crossorigin=\"anonymous\"  &gt;&lt;/script&gt;  &lt;script type=\"text/javascript\"    src=\"https://public.bitmex.com/init.js\"    integrity=\"sha384-n0cKBy1+1+ACIC9J2XunFZItQjpIi1bilP1FCayDxybB40OcUY1ipK4Qjr856KWI\"    crossorigin=\"anonymous\"  &gt;&lt;/script&gt;  &lt;script type=\"text/javascript\"    src=\"https://public.bitmex.com/list.js\"    integrity=\"sha384-Rncjr7coAsbMCINMdkum6h64TPVhqlDpqulDQB/a68yABAgOU21duBLDdlm86oKP\"    crossorigin=\"anonymous\"  &gt;&lt;/script&gt;&lt;/body&gt;수집된 html page의 body tag를 보면 id가 listing인 div tag 하위에 아무런 tag도 존재하지 않는다.이는 저 파일들의 링크를 웹페이지가 로딩 될때 javascript가 생성을 하게 되는데 Beautifulsoup이나request로는 javascript가 로딩 되기 전의 html 소스를 가져오기 때문이다.정적 웹 크롤링은 크롤링 속도가 빠르지만 동적 웹 페이지는 데이터 수집이 되지 않는다는 단점이 있다.상황에 맞게 크롤링 라이브러리를 선택하여 사용하면 된다.BitMex의 Coin Tick data들의 a tag는 동적으로 생성되므로 동적 웹 크롤링이 가능한 Selenium을 써야 한다.Selenium을 이용한 동적 웹 크롤링Selenium 설치웹 크롤링을 할 환경에서 Selenium 패키지를 설치한다.pip install selenium아나콘다 환경을 쓰는 경우 아래와 같이 패키지를 설치한다.conda install -c conda-forge seleniumSelenium은 브라우져를 컨트롤해서 Javascript를 로딩시켜 동적인 결과를 가져오는 방식이다.Selenium에서 브라우져를 컨트롤 할 수 있게 하려면 브라우져의 드라이버를 다운받아서 사용해야 한다.아래의 링크에서 본인이 사용하는 크롬버젼과 같은 버젼을 다운받아야 되는데 Stable Version을 다운 받으면 동일한 버젼의 드라이버를 받을 수 있을 것이다.크롬 드라이버 다운로드현재 사용중인 크롬 브라우져의 버젼 확인은 아래와 같이 확인이 가능하다.이 밖에 edge, firfox, opera 등의 브라우져 컨트롤도 가능하다.  MS Edge Docs: https://docs.microsoft.com/en-us/microsoft-edge/webdriver-chromium/?tabs=c-sharp  Selenium Docs: https://selenium-python.readthedocs.io/Selenium 크롬 드라이버 객체 생성다운받은 chromedriver.exe를 코드파일과 같은 폴더에 넣는 경우 driver = webdriver.Chrome(),다른 폴더에 넣은 경우엔 driver = webdriver.Chrome(driver_path)로 driver 객체를 생성한다.from selenium import webdriverdef get_url_links(url, driver_path=None):    if driver_path:        driver = webdriver.Chrome(driver_path)  # Webdriver의 경로를 지정하는 경우    else:        driver = webdriver.Chrome()  # 코드파일과 같은 폴더에 Webdriver가 있는 경우    driver.implicitly_wait(10)      # 지정된 시간인 10초 안에 페이지의 로딩이 끝나면 다음으로 넘어감.    # 지정된 시간 안에 로딩이 완료되지 않으면 Error띄움.    driver.get(url)if __name__ == '__main__':    url = \"https://public.bitmex.com/?prefix=data/trade/\"    driver_path = '.\\\\chromedriver.exe'    get_url_links(url, driver_path)html element parsing얻으려는 Coin의 Tick data link는 아래의 스샷 처럼 id가 listing 인 div tag 하위의pre tag 하위에 a tag로 이루어져 있다.find_element_by_id('listing')로 id가 listing인 element를 얻고find_element_by_tag_name('pre')로 pre tag 객체를 얻고find_elements_by_tag_name('a')로 a tag인 객체들을 얻는다.여기서 주의할 점은 a tag는 여러개로 element가 아닌 elements 복수로 써야a tag의 객체 list를 얻을 수 있다.from selenium import webdriverdef get_url_links(url, driver_path=None, ext=''):    if driver_path:        driver = webdriver.Chrome(driver_path)  # Webdriver의 경로를 지정하는 경우    else:        driver = webdriver.Chrome()  # 코드파일과 같은 폴더에 Webdriver가 있는 경우    driver.implicitly_wait(10)      # 지정된 시간인 10초 안에 페이지의 로딩이 끝나면 다음으로 넘어감.    # 지정된 시간 안에 로딩이 완료되지 않으면 Error띄움.    driver.get(url)    element_id = driver.find_element_by_id('listing')    pre_tag = element_id.find_element_by_tag_name('pre')    a_tags = pre_tag.find_elements_by_tag_name('a')  # a tag list를 얻음.    links = []    for a_tag in a_tags:        link = a_tag.get_attribute('href')  # href의 link 주소 얻음.        if link.endswith(ext):  # 확장자가 gz 인 link만 links에 append.            links.append(link)    print(links)if __name__ == '__main__':    url = \"https://public.bitmex.com/?prefix=data/trade/\"    driver_path = '.\\\\chromedriver.exe'    get_url_links(url, driver_path, ext)...'https://s3-eu-west-1.amazonaws.com/public.bitmex.com/data/trade/20220809.csv.gz','https://s3-eu-west-1.amazonaws.com/public.bitmex.com/data/trade/20220810.csv.gz','https://s3-eu-west-1.amazonaws.com/public.bitmex.com/data/trade/20220811.csv.gz','https://s3-eu-west-1.amazonaws.com/public.bitmex.com/data/trade/20220812.csv.gz','https://s3-eu-west-1.amazonaws.com/public.bitmex.com/data/trade/20220813.csv.gz']드디어 원하는 Coin들의 tick data link의 list를 얻었다~😊  얻은 link를 일괄 다운로드 하는 방법은 다음의 링크 참조:https://pioneergu.github.io/posts/tick-data-download/"
  },
  {
    "title": "마인크래프트 포지 모드 설치 - (도티TV 초현실 롤러코스터)",
    "url": "/posts/ex-roller-coaster-mod/",
    "categories": "마인크래프트",
    "tags": "ex roller coaster, minecraft java, 도티tv, 마인크래프트 자바, 초현실 롤러코스터, 포지모드",
    "date": "2022-07-01 22:08:00 +0900",
    "snippet": "도티TV 초현실 롤러코스터8살짜리 아들이 도티TV에서 초현실 롤러코스터 모드인 EX Roller Coaster Mod를 보고 해보고 싶다고 해서,자전거를 마스터하면 사준다고 했더니… 하루만에 조금 타게 되더니 3일이 지난 후엔 마스터(?)를 해버리는 것이 아니겠는가??약속대로 아래 링크된 초현실 롤러코스터 모드를 하기 위해 마인크래프트 자바 에디션을 구매하였다…….  저 EX Roller Coaster Mod는 Mincraft Java Edition에 Forge(포지)를 설치하여 Mod를 깔아야한다…(마인크래프트 윈도우즈 에디션도 있는데… 저것 하나 때문에 자바에디션을 추가로 구매를….. 흑흑)롤러코스터모드를 컴퓨터에 설치하고 한참 후에 노트북에 설치해 주려는데….가끔하니 잊어버려서 설치하는데 한참을 버벅 대고 시간을 낭비해 버렸다….그래서 설치법을 정리하려 한다.1.Mod와 동일 Version의 마인크래프트 Java 설치마인크래프트 자바 에디션을 설치하였다면 우선 Minecraft Forge를 설치해야한다.그런데 우선 내가 하려는 모드의 “Version과 같은 Version의 Minecraft와 Forge를 설치”해 줘야 한다.토티TV에 나온 Ex Rollercoaster Mod는 9minecraft 사이트에서 다운로드 받을 수 있는데,그 버젼이 1.7.10이다.따라서, 마인크래프트도 1.7.10을 설치해야 한다.  마인크래프트 1.7.10 Version 설치를 하려면 우선 Minecraft Launcher 상단의 “설치 설정” 버튼을 클릭한다.  새 설치 설정을 클릭  설치환경이름을 적당히 설정해 주고 release 1.7.10을 선택 후 만들기 버튼을 클릭한다.2.마인크래프트 포지(Forge) 설치1.7.10 Version의 마인크래프트 설치가 되었으니 이제 같은 Version의 Forge를 설치해야 한다.그런데 9minecraft 사이트에 연결되어 있는 Forge는 이상하게 설치가 되질 않는다.이것저것 하다보니 Minecraft forge 사이트에서 설치 프로그램을 받아서 설치를 하면 설치가 잘 된다는 것을 알게 됐다.만일 Window가 아닌 다른 운영체제를 사용중인 분은 여기 위키하우라는 곳에서 설치법을 보시면 되고, Windows를 사용하시는 분은 아래를 계속 보시면 된다.  https://files.minecraftforge.net/net/minecraftforge/forge/index_1.7.10.html 여기에 접속해서 Installer를 받아야 하는데 Recommended 를 받는것이 좋다. 우리가 필요한 Version은 1.7.10이니 이 버젼의 Recommended의 Installer를 클릭하자.  참고로 좌측 패널에 다른 Version의 Forge Installer들도 있으니 하고자 하는 게임에 맞는 버젼을 다운받아 설치 하면 된다.  Installer를 클릭하면 다른 광고 화면으로 넘어가게 되는데 여기서 우측 상단을 보면 아래처럼 몇초 기다리라는 메세지가 보이며 잠시 기다리면 SKIP 버튼이 생기게 되는데 이 버튼을 눌러주면 Forge Installer가 다운받아지게 된다.  다운이 받아지는 폴더로 들어가면 아래와 같은 파일이 다운 받아져 있을 것이다. 이 파일을 실행 하려면 자바가 설치되어 있어야 한다.  자바의 설치를 진행하기 위해 아래 링크로 접속해 Windows오프라인(64비트)자바를 다운로드 받고 설치를 진행 해 주면된다.  자바 JRE 다운로드 페이지: https://www.java.com/ko/download/manual.jsp    만일 구버젼 자바가 설치되어 있는 경우 설치해제를 권장하는 문구가 뜨는데 이 경우 꼭 설치해제를 해 주도록 하자.  자바를 설치해 줬으니 아까 다운로드 받은 forge-1.7.10-10.13.4.1614-1.7.10-installer.jar를 더블클릭해서 설치해 주자.  아래와 같은 화면이 뜨면 기본값으로 Install Client가 선택이 되어 있는데 그대로 두고, 설치위치는 C:\\Users\\[User-name]\\AppData\\Roaming\\.minecraft로 되어 있는데 건드리지말고 확인을 눌러 설치를 진행하자.Forge의 설치는 완료가 되었다.이제 Mod 설치에 대해서 알아보자.3. Ex Rollercoaster Mod 설치Mod 설치방법은 매우 간단하다.  우선 “window 키() + R” 키를 누르면 아래와 같이 실행창이 뜨게 되는데 여기에 \"%appdata%\"를 입력하고 엔터를 친다.  %appdata%를 입력하면 아래 그림처럼 Roaming이라는 폴더의 탐색기가 뜨게 되는데 여기서 .minecraft라는 폴더로 들어가 주자.  .minecraft라는 폴더에 들어가서 아래로 조금 내리면 mods라는 폴더가 있다. 여기로 들어가서 위에서 다운로드 받은 모드 파일인 \"ExRollerCoaster-Mod-1.7.10.jar\" 파일을 넣어주자.  이제 마인크래프트 런처를 실행하고 Java Edition을 선택한 후에 플레이 버튼 좌측에 버젼을 선택하는 곳에서 우리가 플레이하려는 버젼인 Forge 1.7.10을 선택하고 플레이 버튼을 누른다.  마인크래프트 Main 화면에 Mods라는 버튼을 클릭해준다.  아래의 화면에서 우리가 설치해 준 \"Ex Roller Coaster\"를 클릭한 후 Done을 클릭하면 끝이다.  롤코 모드를 플레이 하는 모습이다~이제 즐기자~😊"
  },
  {
    "title": "Python - print()로 파일에 출력하기 (sys.stdout - redirection)",
    "url": "/posts/sys.stdout-redirection/",
    "categories": "Python, 1.Generals",
    "tags": "python, print, redirection",
    "date": "2022-04-11 17:05:00 +0900",
    "snippet": "print() 함수로 파일에 기록(출력)하기print() 함수를 사용하면 기본적으로 콘솔창에 출력이 된다.그런데 이걸 파일에 기록하고 싶을 때가 있는데 이 때에는 sys.stdout을 redirection 해 주면 된다.아래의 예제코드를 보자.import sysoriginal_stdout = sys.stdout  # original stdout을 임시 저장file_path = \".\\\\log_test.txt\"log = open(file_path, \"w\")sys.stdout = log  # stdout을 log_test.txt로 redirectionprint(\"hello world\")sys.stdout = original_stdout  # sys.stdout을 원래로 돌림.print(\"printing at console\")결과를 보면 콘솔창에는 아무런 출력이 없고 아래와 같이 log_test.txt파일에 출력을 명령한 hello world가 입력되어 있는 것을 볼 수 있다.그리고 stdout을 원래대로 돌려놓고 print 한 것은 console창에 잘 출력이 되는 것을 볼 수 있다.printing at consoleprint() 함수로 파일에 기록(출력)하기 - Context Manager이번에는 context manager를 이용해서 파일에 출력하는 것을 보자.import sysfile_path = \".\\\\log_test.txt\"with open(file_path, 'w') as log:    original_write = sys.stdout    sys.stdout = log    print(\"hello world!\")    sys.stdout = original_writeprint(\"printing at console\")마찬가지로 잘 출력이 되는 것을 확인 할 수 있다.printing at console끝~👌"
  },
  {
    "title": "Python sys.stdout.flush()",
    "url": "/posts/sys.stdout-flush/",
    "categories": "Python, 1.Generals",
    "tags": "python, stdout, flush",
    "date": "2022-02-14 14:56:00 +0900",
    "snippet": "print function아래의 help(print)를 보면 print() 함수는 default로 줄바꿈을 해준다.help(print)Help on built-in function print in module builtins:  print(...)      print(value, ..., sep=' ', **end='\\n'**, file=sys.stdout, flush=False)         Prints the values to a stream, or to sys.stdout by default.      Optional keyword arguments:      file:  a file-like object (stream); defaults to the current sys.stdout.      sep:   string inserted between values, default a space.      `end`:   string appended after the last value, default a newline.      flush: whether to forcibly flush the stream.  그런데 console 창에서 아래의 코드를 실행 하면 1초마다 숫자를 띄워주는 것이 아니라 3초가 다 지난 후에 결과를 한꺼번에 띄워 진행 상황을 알 수가 없다.  기본적으로 python에서는 개행문자'\\n'을 받기 전까진 문자열을 출력하지 않기 때문이다.아래의 코드는 default인 end='\\n'을 한 칸의 띄우는 end=' '로 바꿔줬기 때문에 console창에 출력을 하고 있지 않다가 코드 실행이 종료되면 한꺼번에 그 결과를 띄워준다.(참고로 이는 시스템마다 다른데 예로 같은 코드를 jupyter notebook에서 실행하면 1초마다 출력을 해서 진행 상황을 알 수 있게 해준다.)import timeimport sysfor i in range(3):    print(i, end=' ')    time.sleep(1)0 1 2 3stdout.flush()  stdout.flush()는 print()함수의 개행 여부와 상관 없이 출력을 해 주는 기능을 한다.만일 줄바꿈이 없는 문자열을 진행상황을 확인하면서 출력하고 싶을 때는flush=True로 해줘 버퍼에 있는 문자열을 모두 출력하게 해준다.import timeimport sysfor i in range(3):    print(i, end=' ', flush=True)    time.sleep(1)# 1초 후...0# 2초 후...0 1# 3초 후...0 1 2아래 처럼 print문 다음에 sys.stdout.flush()를 호출해줘도 똑같은 결과가 나온다.import timeimport sysfor i in range(3):    print(i, end=' ')    sys.stdout.flush()    time.sleep(1)# 1초 후...0# 2초 후...0 1# 3초 후...0 1 2"
  },
  {
    "title": "Python Sequences",
    "url": "/posts/Python-Sequences/",
    "categories": "Python, 3.Iterables and Generator",
    "tags": "python, sequence, mutable, immutable",
    "date": "2022-02-04 17:54:00 +0900",
    "snippet": "Sequence TypePython의 Sequence type은 Mutable과 Immutable Sequence Type으로 나뉜다.Immutable Sequence Type에는 String과 Tuple이 있다.            Mutable Sequences      Immutable Sequences                  list      string              bytearrays      tuple                     range                     bytes        NOTE: Mutable은 내용의 변경이 가능한 Type이며, Immutable은 변경이 불가능하다.tuple element의 값을 변경하는 코드를 실행해보자.t = (1, 2, 3)t[0] = 10---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-3-155b9e8fb284&gt; in &lt;module&gt;()----&gt; 1 t[0] = 10TypeError: 'tuple' object does not support item assignment위 코드의 실행 결과처럼 tuple에 새로운 값을 assign하려고 하면 TypeError를 띄우게 된다.반면 tuple안에 mutable sequence type인 list가 있는 경우,list의 element는 수정이 가능하다.&gt;&gt;&gt; t = ([1, 2], 2, 3)&gt;&gt;&gt; t[0][0] = 10([10, 2], 3, 4)Concatenation and RepetitionConcatenate는 + operator를 사용하여 할 수 있고,Repetition은 * operator를 사용하여 할 수 있다.그리고 Concatenate 및 Repetition은 언제나 새로운 Object를 반환한다.Concatenation# Concatenationl1 = [1, 2, 3]l2 = [4, 5, 6]l3 = l1 + l2print(f\"l3: {l3}\")print(f\"id of l1: {id(l1)}\")print(f\"id of l2: {id(l2)}\")print(f\"id of l3: {id(l3)}\")l3: [1, 2, 3, 4, 5, 6]  id of l1: 2619302087680  id of l2: 2619302081984  id of l3: 2619308460288  위의 결과를 보면 알 수 있듯이 Concatenation의 결과인 l3는 l1 및 l2와 다른 메모리 주소를 보여준다.아래의 Inplace-concatenation을 보면 메모리 주소가 변하지 않는 것을 볼 수 있다.# inplace-concatenationl1 = [1, 2, 3]l2 = [4, 5, 6]l3 = l1.extend(l2)print(f\"l1: {l1}\")print(f\"l3: {l3}\")print(f\"id of l1: {id(l1)}\")print(f\"id of l2: {id(l2)}\")print(f\"id of l3: {id(l3)}\")l1: [1, 2, 3, 4, 5, 6]  l3: None  id of l1: 2619302087680  id of l2: 2619314922560  id of l3: 140719011362992  l3를 보면 None인 것을 볼 수 있는데 Inplace-concatenation은 Return이 없이 자기 자신을 변경 시키는 것이 특징이다.다른 Type의 Sequence를 Concatenation하면 TypeError를 띄운다(1, 2, 3) + [4, 5, 6]---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-25-67a9e2ed8695&gt; in &lt;module&gt;()----&gt; 1 (1, 2, 3) + [4, 5, 6]TypeError: can only concatenate tuple (not \"list\") to tuple'abc' + ['d', 'e', 'f']---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-26-8cbdd441adc1&gt; in &lt;module&gt;()----&gt; 1 'abc' + ['d', 'e', 'f']TypeError: must be str, not list아래와 같이 해결 가능하다.&gt;&gt;&gt; (1, 2, 3) + tuple([4, 5, 6])(1, 2, 3, 4, 5, 6)&gt;&gt;&gt; tuple('abc') + ('d', 'e', 'f')('a', 'b', 'c', 'd', 'e', 'f')&gt;&gt;&gt; ''.join(tuple('abc') + ('d', 'e', 'f'))'abcdef'참고로 tuple은 immutable sequence type이므로 concatenation을 할 경우 New object를 생성한다.Repetition# Repetitionl1 = [1, 2, 3]l2 = l1 * 3print(l2)print(f\"id of l1: {id(l1)}\")print(f\"id of l2: {id(l2)}\")[1, 2, 3, 1, 2, 3, 1, 2, 3]  id of l1: 2619302087424  id of l2: 2619314821952Repetition도 마찬가지로 l2 의 메모리 주소가 l1과 다른 New object를 Return한다.Slicingsequence[start, stop, step] 으로 사용할 수 있다.또한 start가 비어있으면 0을, stop이 비어있으면 맨 마지막을 가르킨다.그리고 stop이 range를 벗어나도 문제가 없다.&gt;&gt;&gt; l = [1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; l[0:3], l[:3], l[3:6], l[6:9], l[6:], l[6:100]([1, 2, 3], [1, 2, 3], [4, 5, 6], [7, 8, 9], [7, 8, 9], [7, 8, 9])sequence[start:stop:step]는 sequence[slice(start, stop, step)]과 동일하다.l = [1, 2, 3, 4, 5, 6, 7, 8, 9]sl = slice(0, 3)print(l[0:3])print(l[sl])[1, 2, 3][1, 2, 3]-를 써서 slice도 가능한데 맨 마지막 위치가 -1로 시작해서 좌측으로 갈수록 -1씩 더해주면 된다.그리고 step을 -1을 주면 반대로 slicing을 한다.&gt;&gt;&gt; l = [1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; l[-3:-1], l[::-1]([7, 8], [9, 8, 7, 6, 5, 4, 3, 2, 1])Finding in SequencesSequence 안에 element의 index를 찾는 법.index(찾을것)&gt;&gt;&gt; s = \"hello python\"&gt;&gt;&gt; s.index('h')0Optional로 찾기 시작할 위치를 start로 지정가능 하며,optional로 end를 지정할 수도 있다.index(찾을것, start, end)&gt;&gt;&gt; s = \"hello python\"&gt;&gt;&gt; s.index('h'), s.index('h', 5), s.index('h', 5, 13)(0, 9, 9)만일 찾고자하는 element를 찾지 못하면 ValueError를 띄운다.&gt;&gt;&gt; s = \"hello python\"&gt;&gt;&gt; s.index('h', 10)---------------------------------------------------------------------------ValueError                                Traceback (most recent call last)&lt;ipython-input-25-669dc875185c&gt; in &lt;module&gt;----&gt; 1 s.index('h', 10)ValueError: substring not foundValueError로 인해 프로그램이 종료되는 것을 방지하기 위해서,아래와 같이 예외처리를 해 줄 수 있다.s = \"hello python\"try:    s.index('h', 10)except ValueError:    print('finding element is not exist')finding element is not existCaveats (주의사항)list object를 Concatenation을 하게 되면 Return되는 object는 New object이다.하지만, copy된 list 내부의 element는 original element를 그대로 referencing하게 되어 같은 id를 가지게 된다.element자체가 immutable object라면 element를 수정할 때 immutable이기 때문에 수정하려는 값으로 reference를 바꾸게 되어 문제가 없지만,mutable object면 orinal object의 element를 수정할 때 copy본의 element도 같이 수정되는 의도치 않은 문제가 생길수 있게 된다.  참고사항          Mutable object: list, set, dictImmutable object: int, float, complex, bool, string, tuple, frozen set, range      a = [[1, 2]]l = a + aprint(l)print(id(l[0]), id(l[1]))print(l[0] is l[1])[[1, 2], [1, 2]]  2619315234368 2619315234368  Truea[0][0] = 50print(l)[[50, 2], [50, 2]]  original list의 element를 수정하였으나 copy본인 l의 element가 다 바뀌어버리는 의도치 않은 결과가 나오게 된다.이와 관련해서 다음 copy에 대해서 자세히 다뤄보도록 한다.NEXT: Shallow Copy, Deep Copy"
  },
  {
    "title": "Jekyll 테마를 이용해 GitHub 블로그 만들기",
    "url": "/posts/jekyll-theme-make/",
    "categories": "Git, Github-Blog",
    "tags": "blogging, jekyll, github",
    "date": "2022-01-25 23:24:00 +0900",
    "snippet": "Github Blog (with jekyll theme) 사용 이유뭔가 멋들어진 이유가 있기보단.. 프로그래머분들의 Blog를 보다보면많은 분들이 GitHub blog를 사용하고 계셔서 관심이 생기게 되었다.비록 전공자는 아니지만 기왕 Programming을 배우기 시작한거Git도 배워볼겸 GitHub blog를 만들어보기로 마음을 먹게 되었다.Jekyll-theme-chirpy 테마 선정Google에 jekyll theme이라고 검색을 하면 jekyll 테마를 모아둔 여러 사이트가 검색되는데그 중에서 개인적으로는 아래의 사이트가 Jekyll theme를 카테고리별로 볼 수 있어 마음에 든다.  Jekyll theme 모음: https://jekyll-themes.com/처음에 고른 jekyll theme는 lanyon theme였다.아주 Simple해서 마음에 들었었는데…초보자인 내가 category나 tag기능 등을 직접 만들어 Customizing하기엔 시간낭비가 크다는 느낌을 받았다.(이것 말고도 배울게 많은데…)뭐 그래도 lanyon theme에 category를 직접 만들어 보면서 jekyll site에 대한 이해도가 많이 올라가서큰 도움이 되었다.결국 있을 웬만한 기능은 다 있고 깔끔한 Dark(and Light) theme인 Chirpy theme를 선택하게 되었다.(현재 이 Blog theme이다.)이 테마를 적용하고 나서 좀 더 검색을 해보니지금 이 theme보다 나름 더 예쁘다고 생각되는 design의 theme(devlopr theme)를 발견하였다.순간 theme를 바꿀까 고민했지만… 차차 이 Blog를 나만의 Design으로 꾸며보기로 결정했다!내 마음에 드는 테마들  Simple and Clean Theme                  Lanyon Theme: https://lanyon.getpoole.com/                      Github: https://github.com/poole/lanyon                          Clean Blog Theme: http://startbootstrap.github.io/startbootstrap-clean-blog-jekyll/                      Github: https://github.com/StartBootstrap/startbootstrap-clean-blog-jekyll                                Dark and Funtional Theme                  Chirpy Theme: https://chirpy.cotes.page/                      Github: https://github.com/cotes2020                          Devlopr Theme: https://devlopr.netlify.app/#/                      Github: https://github.com/sujaykundu777/devlopr-jekyll                              Jekyll-theme-chirpy 테마 설치Chirpy Theme처음에 Jekyll 테마 설치를 블로그들을 보면서 설치를 했었다.그런데 내 테마랑 맞지 않는 설치법을 보고 설치를 하다보니 GitHub에 Deploy오류가 난다던지 여러 오류로 오랜시간을 낭비하고 스트레스만 쌓였었다.알고보니 내가 선정한 테마에 맞는 설치법을 이미 테마 개발자가 잘 올려놨던 것이다…😱그간의 노력들이 허무해 진 순간이었다…OTLChirpy Theme의 설치법은 아래의 Chirpy theme Demo Site에 잘 나와 있다.  https://chirpy.cotes.page/posts/getting-started/어떤 테마던 테마개발자 GitHub에 README.MD 나 Demo Site를 보면 설치법이 아주 잘 나와 있을 것이다.끝~!👍"
  }
]
